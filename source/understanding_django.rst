理解Django
**********

埋头写代码是不够的。
代码虽然是由计算机来运行，但终究是由人来编写的。
写程序的人必须坐下来好好思考几个问题：
应该添加哪些功能，这些功能应该怎么实现，有哪些软件可以加以利用，为了未来的扩展性应该怎么添加钩子。
很多人往往追求结果，而忽略过程，噼里啪啦地开始敲键盘码字。
但一个成熟的程序员，对于自己做的每一个决策都是深思熟虑的。

使用一个类似Django的框架，很多类似的决策其实已经制定好，框架还对每种决策提供了相对应的工具。
在你自己的代码中，使用这些设计哲学。
不但可以使你跟Django还有其他的应用保持一致，你还会感叹自己构架出来的东西是多么的惊艳。

即使是最简单的代码背后，也蕴含着创作的思考过程。
它应该实现什么功能，怎么来实现这些功能，这些都是决策所需要考虑的问题。
在很多书和编程手册里，这个思考的过程往往被忽略掉。
这导致了一大群技术人员埋头苦干，仅仅为了完成手头上的任务而编程，而不是放眼未来。

本书剩余部分会详细介绍，Django支撑复杂项目的很多基本构件(basic building block)，但这一章会专注于框架基础原理的方方面面。
对于从其他背景过来的读者，这一章可能显得格外陌生，但这并不意味着这章不重要。
所有从事Python和Django的程序员，都应该对Django的设计理论有着扎实的理解，并且能够把这套理论运用到其他项目中去。

你可能想要反复阅读这一章，并且在使用Django的过程中经常翻阅。
在Django社区里，这章的很多观点已经是常识。
如果你打算与其他人协作，你必须仔细阅读此章，否则被人鄙视就不好了。


哲学
====

Django非常重视哲学的运用，这点体现在Django的代码和构架当中。
在编程领域里，这不是什么新鲜事，但初学者经常会身陷泥淖。
维护一致性和质量是基本要求，在维护的过程中，我们有一系列基本理论来帮助我们决策。TODO:这句话没翻译通。
这些理论对于独立程序，甚至程序集，也同样地重要，好好把握这些设计哲学，也会有类似的效果。

Tim Peters写的这段Python哲学，也许是最广为人知，被引用最多的。
Tim Peters长时间来是Python界的领军人物，写下了大量理论指导Python自身的开发进程。
这短短19行小诗，被称之为Python之禅(Zen of Python)。
在Python程序员中影响力甚远，被写入 PEP20 [#f1]_ 作为永久纪念。
还写入了Python标准模块--“彩蛋”模块this。

.. code-block:: pycon

    >>> import this
    The Zen of Python, by Tim Peters

    Beautiful is better than ugly.
    Explicit is better than implicit.
    Simple is better than complex.
    Complex is better than complicated.
    Flat is better than nested.
    Sparse is better than dense.
    Readability counts.
    Special cases aren't special enough to break the rules.
    Although practicality beats purity.
    Errors should never pass silently.
    Unless explicitly silenced.
    In the face of ambiguity， refuse the temptation to guess.
    There should be one-- and preferably only one --obvious way to do it.
    Although that way may not be obvious at first unless you're Dutch.
    Now is better than never.
    Although never is often better than *right* now.
    If the implementation is hard to explain， it's a bad idea.
    If the implementation is easy to explain， it may be a good idea.
    Namespaces are one honking great idea -- let's do more of those!

虽然其中有部分明显是诙谐之句，但他很好地总结了Python的特性。
这章剩余内容会标记一些经常被Python社区引用的哲学，但所有的专业Python程序员都会把这段小诗永记于心，并且经常引用。

有一点请你必须记住，Python之禅里面很多内容都是非常主观的。
例如：“优美”比“丑陋”好，但“优美”的定义是因人而异的。
同样的道理，对于“简单”和“复杂”，“实用性”和“纯洁性”，每个开发者在认识上其实都有偏差。


Django对MVC模式的演绎
-------------------

MVC模式是其中一种被广泛应用的软件构架，它清晰地分割了一个软件各个重要部分的任务和责任。
Django只是轻度借鉴了这种构架。
我们不对MVC作过多讨论，而直接来看看它各个部分的概述。

- 模型，负责管理数据和核心业务逻辑。
- 视图，向用户展示数据。

控制器接收用户的输入，并在应用里执行相应的业务逻辑。
在很多领域里，MVC模式已经证明为非常高效。
但从创建Django之初，Django的创建者们就不想直接套用现有的任何构架模式。
他们只是想寻找一种简单高效的方式来开发Web软件。
毕竟，Django创建之初的目的，是为了满足报社的日常工作，需要快速跟得上需求的更改。
最终，因为不同的需求而把任务分割成不同的模块。

- 为了一系列特定任务而写的代码非常好维护，因为它不需要假设程序还有其他的无关部分。
  一般而言，这种观点叫“关注点分离”(separation of concerns)。而且在整个软件开发过程中，这种方法是适用的。
- 应用开发变得更加灵活，多个不同的视图层和控制器层，可能都是连接到同一个模型层。
  这允许不同的应用，可以共享相同的业务逻辑和数据。让关注不同部分的各个人，都能有不同的途径进行交互。
- 开发者只需要学习自己使用到的相关部分，而不需要把整个系统都过一遍。
  这特别有助于减轻挫败感和疲劳，让开发者可以在自己的领域里培养创新和成功。

当然使用MVC模式还有其他的小优点，但这些是它的主要优点。
需要注意的是，在MVC模式里进行这种划分，其主要的好处是可以把多个应用插入到同一个模型层。
剩下的唯一好处是，可以基于开发计划，来进行任意划分各个部分。

Django开发者把握这些MVC的优点，但更加专注于快速开发，为他们的工作流程创造了一系列靠谱的工具。
最终，他们创造了一种新的模式：模型-模版-视图(MTV)。
但事实上，一个Django应用是分为了四个主要组成部分，我们下面会详细讲述。

模型
^^^^^

考虑到把模型从应用中分离而带来的好处，Django严格继承了MVC模式中的M。
Django模型提供了一套便捷访问底层数据储存的机制，而且可以封装一些公共的常用核心业务逻辑。

模型的存在依赖于系统的其余部分。
模型设计的目的，就是给那些能够访问到他的应用使用。
事实上，我们可以直接从交互命令行(interactive interpreter)，利用模型实例来完成对数据库的操作，而不需要加载一个Web服务或者任何应用逻辑。

在第三章会对Django的模型作更详尽的讲解，包括他们是怎么被定义和利用，怎么嵌入到你的业务逻辑，等等。

Django视图跟传统MVC定义的视图只是名字一致，Django视图比传统范式包含了更多的东西。
Django视图，把传统视图的一些功能，和整个控制器的功能融合在了一起。
本文下面的视图，没有特别指代的，默认为Django视图。
视图接受用户的输入(包括一些简单的请求信息)，根据应用的交互逻辑来设定视图的行为。
再根据不同的用户场景，展示出模型渲染的数据。

视图通常是一个普通的Python函数，当用户请求一个特定的URL时会被调用。
根据Web协议(HTTP协议，译者注)，即使是一个简单的信息请求，也会被视为一个动作，所以视图需要处理数据修改以及其它提交。
为了完成用户发起的请求，视图必要时可以访问模型，进而获取和更新信息。

由于视图可以像一个简单的函数似的被调用，没有用到什么特殊的结构，所以视图可以有很多种方式来实现。
不仅仅可以是一个简单的函数，一个视图可以表现为任意Python回调，包括类，类实例方法(instance method)，可调用对象(callable object)，
加里化(curry)函数，装饰过的函数。

模版
^^^^

技术上，视图负责把数据呈现给用户。
可 *如何* 展示数据呢?这个任务一般来说分配给了模版。
模版在Django的开发中实在太重要了，以致他被分离成独立的一层。
由于模版负责了所有用户能看到的展示效果，很多人认为Django模版等同于传统的视图层。

Django已经提供了一套简易的模版语言，模版设计师不需要为了做模版而去学习Python。
Django模版语言不基于任何特定的描述性语言。
Django模版主要用来生成HTML，但他也可以生成任意基于文本的其他格式。

牢记，这个模版引擎不仅仅用来渲染可阅读的页面。
很多时候，视图可以使用HTTP重定向到其他URL，第三方PDF库，或者其他用来生成他们输出的东西。

URL配置
^^^^^^

作为一个Web框架，Django提供了一个独立的胶水层，访问不同的URL可以向外界展示不同的视图。
URL配置（胶水层）由正则表达式组成，一条正则表达式可以囊括非常多的URL。
这种方式可读性高而且方便维护。

这个URL配置单独定义，与视图分离，使得一个视图可以对应多条URL，每个地址还可以有不同的选项。
事实上，这是Django的核心之一：普适视图的理念(concept of generic views)。
这些视图的意义在于可以重复利用，使用一些配置选项让它们可以适用于任何应用，你所需要做的只是添加一条URL配置来激活它。

可能最重要的一点是，把URL作为单独的一部分，能够推动开发者把URL纳入应用整体设计的一部分。
由于他们必须用在书签，博客文章，营销活动中，有时候URL的曝光率比你的应用还高。
毕竟，用户浏览网页时，在他们决定是否访问你的网站之前，看到的是你的URL。
当使用印刷媒体进行广告营销时，URL就更显得重要了。

第四章将详细讲述URL配置，包括一些关于设计适当URL的指导。

松耦合（Loose Copling）
---------------------

MVC构架，或者是Django这个小修改后的构架，有一个很关键的概念：功能上有着显著区分的各部分部件，不应该依赖其它部件的运作。
这叫松耦合。
紧耦合（tight coupling）与此相反，它的模块常常严重依赖于其他模块实现的内部细节。

紧耦合会令到那些维护周期长的代码产生大量的问题：对于一个模块的重大改变，会不可避免地影响到其他模块。
这给程序员带来大量额外的工作，当所依赖到的代码发生变化时，他就不得不作一些相应的修改来适应变化。
这些额外工作不仅影响到了程序员，对雇主来说也是一个很大的负担。
紧耦合很难把独立的行为分离出来，也使得测试变得更加困难。

看上去，松耦合提倡，任何代码都不应该知晓其他代码的存在。
但是这样子的程序基本上是什么也干不了的。
某些代码模块会不可避免引用到其他的模块。
关键在于实现的时候，这个依赖应该越小越好。

在Python世界，我们有很多种方式来实现松耦合，下面列出来其中的一些。
还有无数种其他的方法，这足以写满一本书，但我们在第二章只会讲述以下的几个技术点。

- 鸭子类型（Duck typing）
- 运算符重载（Operator overloading）
- 信号和调度（Signals and dispatching）
- 插件（Plugins）

Don't Repeat Yourself（DRY原则）
-----------------------------

如果你已经有过几次写代码的实践，你就会知道写“样板”代码是多么地容易。
你的代码一次只写一个功能，然后继续写下一个功能，下一个功能，下一个功能。
你过了一会就会发现，你写的代码是多么地重复。
幸运的话，你可能会有愉快的心情和时间精力，来分析哪些代码是可以挪到公共模块的。

这个过程就是框架存在的其中一个主要原因。
框架提供了很多公共方法，令到你可以避免在将来再去写重复的代码。
以上，展示了一个脍炙人口的编程实践：Don't Repeat Yourself。

它常缩写为DRY，我们经常会在对话中用到这个词，例如：

- 作为名词--"这代码违反了DRY原则"
- 作为形容词--"我喜欢那个实现，这很DRY"
- 作为动词--"我们把他DRY一下吧"

DRY原则的基本要求是，对于同样的代码你只需要写一次。
一旦相同功能的代码你重复写到了两处地方，当需要修改代码时，你漏改了一处代码就会引起不一致的风险。
而且应该尽可能做到复用，当其他代码需要感知你写好的代码时，你应该利用Python的特性来自动获取必要信息，而不要程序员去重复这个动作。

为了能够做到这点，Python提供了很多途径来检视你的代码，此过程称之为内省（introspection）。
在第二章将详细讲解，这对你代码DRY时非常有用。

专注可读性
---------

在之前的Python之禅也提及过，"Readability counts." 。
这可能是Python最重要的特性之一。
事实上，Python语言本身及产出代码都具备很高的可读性，令到很多Python程序员自以为豪。
其主要思想是，人们阅读代码的频次要比写代码的频次高得多。在开源世界里这种情况更甚。

Python提供了很多特性来提高可读性。
比如，它尽可能少用标点，强制使用缩进，在语法层面提高你代码的可读性。
当你实际写代码时，还有其他更多因素需要考虑。

为了提高代码的可读性，Python社区就代码风格编写出了一套指南。
正如PEP-8 [#f2]_ 写的那样，这套指南不仅是为了提高某个程序的可读性，更重要的是保持了不同程序之间的一致性。
当你看一个书写良好的程序很有感觉时，其他的程序也就能举一反三了。

我们就不在这细说PEP-8，它内容太多了，强烈建议读者通过阅读它来学习，怎么写出可读性高的代码。
有一点要注意的是，当你阅读Django的源代码，你会发现它并没有完全遵从PEP-8。
讽刺的是，假如你严格准守PEP-8的每条规则，有时候反而会导致一些问题。
总言而之，再次引用Python之禅，"Practicality bests purity"（译者注：不要为了保持代码的“纯洁性”，而忽略了实际的需要）。
本书的所有例子会遵从Django的源代码风格。

大声爆错（Failing Loudly）
----------------------

"Errors should never pass silently. / Unless explicitly silenced." （译者注：错误永远都不应该沉默，除非你显式指定它沉默）
这看似是一句简单的感情告白，只有短短两行，却占据了Python之禅十分之一的篇幅。
在Python里这两句话说得尤其正确。
所有的编程语言都会产生错误，大部分语言可以优雅地处理错误。
不同语言对于处理错误有不同的最佳实践。

你需要记住一个关键点：大部分Python异常的名字都是以Error结尾的，但基类的名字却叫Exception。
我们首先学习的点是：为什么要使用这个特别的单词（Exception），从而学习怎么处理和使用异常。
在一些字典里查找单词"exception"，可以看到很多种解释。
（译者注：不知道原作者从哪找到的解释，译者还没牛逼到翻译字典的地步，下面解释是从牛津英汉词典找的）

- 一般情况以外的人（或事物）; 例外
- 规则的例外; 例外的事物

比起错误，异常更像是一种场景描述：当一些没预见的事情发生了，异常描述了这个问题发生的场景。
这其中有着微妙的区别，某些人却把异常统统当成错误，把异常当作是不可恢复的错误，例如损坏的文件或者是网络失败。
他们还会举出一些事实依据：在一些语言中，抛出异常的代价非常昂贵，为了避免性能问题，异常在任何时候都应该避免。

在Python里，抛出一个异常的代价，并不比简单返回一个值更昂贵。
所以，让异常更加贴近它字典所定义的吧。
假如我们定义一个异常，是因为它违反了某条规则，那么显而易见，我们必须得先定义这条规则。

.. seealso::

    定义规则

    要想把异常理解透彻，这是最重要的一个点。而且头脑必须清楚一点：自古没有定义这些规则的Python语法。
    这已经超出了语言的范畴。
    有一些语言显式支持契约式设计（design by contract，也就是DbC） [#f3]_ ，还有很多语言是通过框架级的代码来实现，但Python原生不支持定义这些规则。

.. 这个位置衔接不顺，感觉是原书排版问题

反而，程序员会根据他们代码的需要，来定义这些规则。
这看上去好像过分简化了，其实不然。
代码应该严格遵从作者的意图，不做多余的事情。
任何不在程序员意料中发生的事情，都应该被视为异常。
举例说明这点，下面是Python和Django的一些规则：

- 访问列表（list）的某个元素，应该使用中括号语法（my_list[3]），返回列表某个位置的元素
- 集合（set）的discard()方法，可以保证某一个元素不再是集合的成员。
- QuerySet的get()方法，根据传进的查询参数，返回单独的一个对象。

类似这样的规则很重要。
即使这些规则很简单，但他们精确地描述了在不同场景下这些功能的行为。（译者注：这些功能指的是，访问列表的某个元素，discard()方法，get()方法）
为了进一步举例说明，考虑以下场景，看看规则是怎么影响行为的。

- 我们给出一个索引位置，如果列表在该位置有元素存在，则返回相应的值。
  如果不存在，则抛出一个异常（IndexError）。
  如果使用的索引不是整形（integer），则抛出另一个异常（TypeError）。

- 当使用discard()函数移除集合里的某个元素时，如果这个元素在集合内，则简单移除。
  如果这个元素不在集合内，discard()函数不会抛出一个异常，因为discard()只是保证这个元素不在这个集合内。

- 调用QuerySet的get()方法，如果在数据库里面找到相符的一条记录，那么这条记录就会被封装成相应模型的实例并返回。
  如果没有找到相符的记录，则抛出一个异常（DoesNotExist）。
  但如果有不止一条记录返回，则抛出另一个异常（MultipleObjectReturned）。
  最后，如果传进去的参数不能被用来查询数据库（由于类型错误，未知的属性名字或者其他原因），则抛出异常（TyepError）。

明显，哪怕是最简单的规则也有其深厚的影响，从他们被显式定义开始，一直影响至今。
作者需要清晰知道这些定义的规则，但如果不把这些规则传达给其他人，那这些规则就发挥不了其作用。
这点在诸如Django的框架中，尤其重要，因为他的开发是由大众来完成的。

文档规范
^^^^^^^

我们有很多种的方法来定义这些规则，每段代码都应该遵从这些规则。
通过不同途径，多个层次，来记录下这些规则是大有裨益的。
人们主要会从四个地方看到这些信息，假如你把文档放到这四个地方或者其中一个，就能让别人看到你的文档。

- 应用文档（Documentation） -- 他应该储存了这个应用的所有信息，合乎情理，这些规则也应该被包含在此。
- Docstrings -- 独立的注释文档，开发者经常会翻看代码，看看他是怎么工作的。
  Docstrings就是代码旁的文本注释，解释这段代码是怎么实现的。
- 测试（Tests） -- 除了解释这些规则给人类理解，我们也可以给Python解释这些规则。
  这可以让你的代码在一个基准场景中得以验证。
  除此以外，我们也会使用doctest。
  doctest就是把测试写到docstrings里，对人类而言可读性也比较高，达到一箭双雕的效果。
- 注释（Comments） -- 有时候，一个函数实在太复杂了，在完整文档甚至docstring里找到的概述，都不能充分说明这一大段代码是用来干神马的。
  虽说Python注重可读性，遇到这种情况相当罕见，但我们仍然会遇到。
  一旦遇到这种情况，注释有助于解释给别人听，这段代码目的是什么，从而知道什么情况应该被考虑为异常。
  尤其注意一点，注释应该解释代码的目的，而不是每一行代码实际在干什么。
  多想想 *为什么* ，而不是 *做什么*。（译者注：这一点也是很多初学者会犯的错误）

不管你用什么方法来描述你的规则，第一件事必须记得：显式定义你的规则。
记住，任何在你规则之外的情况，都应该被视为异常。
所以，显式定义你的规则，有助于清晰你编码时的思考决策：不同的场景下，你的代码应该有着怎样的行为，包括应该在什么时候抛出异常。

还有一点：保持一致性。
很多类和函数，名字或者接口看上去都差不多，那么不管他们在什么地方，他们的行为都应该是类似的。
程序员总是想在类似的组件上，获得类似的使用体验。
你最好是满足他们的欲望罗。
所以你在写代码的时候，最好模仿Python或者Django里面的套路。
这些套路已经有很完善的文档，而且广泛被程序员所接受。

社区
====

自2005年向外发布后，Django在技术上和文化上都获得了巨大的成功。
在Python Web开发的爱好者和专业人士中，Python积累了一大批粉丝。
这个社区对于框架还有他的用户而言，是一项最伟大的财富。
一些细节我们值得继续讨论。

.. seealso::
    一个进化中的社区


    你一定要意识到Django社区像任何一个社会结构一样，一直在进化和改变。
    所以这章的内容，可能已经不能准确地反映社区此时的实践和期望。


没有理由因此而阻挡你前进的脚步。
有一件事我最希望能够一直传承下去：社区乐意去拥抱新成员。
只要你愿意把自己泡在那，你总可以接触到大量的人。

框架的管理
---------


对于Django的开发，还有Python的开发，你首先要知道：框架的代码是每个人都可以查看和修改的（毕竟他是开源的），但对核心的全权管理是由一小部分人监控的。
有权限更新主代码仓库的人组成了这些"核心开发者"。

.. seealso::

    何谓"核心"?

    Django是开源的，所以任何人都可以去修改Django的源代码，并发布这些修改后的版本。
    很多开发者已经在这么干了，添加一些有意义的特性和增强功能，再把他们的成果分享给其他人。
    一些高级使用者可以对核心代码做一些非常重大的修改，而不会影响到那些没有用到这些特性的使用者。

    此外，允许和鼓励开发者把他们的应用做得更加通用，然后把应用分发给其他人。
    有些优秀的应用传播得越来越广泛，使得他们在新项目开始的时候，就把这些应用默认加入。

    比较起来，Django的核心，仅仅是在Django主站分发的代码而已，比如一个官方的发布，或者源代码开发主分支。
    所以当讨论甚至争论是否应该把一些东西加入核心时，其争议是：应该把他加入官方的发布中呢?还是当作第三方资源，譬如一个分支或者是一个分发的应用。

    所以诞生了一个有趣的灰色地带：django.contrib包。
    它被包含在Django主发行中，是核心的一部分，但它们是被设计成第三方应用来使用。
    其意义是，当一个第三方的应用写得足够好，在社区里获得了足够的吸引力，并且承诺会持续支持下去，最终他就会被加入到核心。
    可事实上，他们经常会走向另一条路，从核心删除django.contrib包，作为第三方应用维护下去。（译者注：这句话没有翻译通，跟事实不符）

这种结构有助于那些优秀的应用，在提交到源码库之前，能够反复调优（译者注：这句话也没译通）。
核心开发者也经常对最近框架的开发问题进行讨论，还有讨论一些需要完成的大修改和重要改良，等等。

虽说核心开发者的地位很高，但仍然有人是站在管理链的最顶层。
这个职位叫 仁慈的独裁者（Benevolent Dictator for Life），缩写为BDFL。
处于这个职位的人，对于所有决定有着至高无上的权力，他需要打破平局，或者推翻大多数人的决定。
幸运的是，他们真的是"仁慈的"独裁者，不会轻易地做出决定。

事实上，BDFL这个头衔，象征意义比实际意义要大。
他们虽然拥有无限的权力，但极罕见会使用这个权力，因为他们会听从群众的意见。
当他们需要干涉并仲裁一个决定时，他们的立场是基于多年来的经验：对于框架和用户而言，什么是最有利的。
事实上，他们经常会向社区详细描述他们的想法。假如有合理的反对意见出现，他们甚至会屈服于社区。

对于那些公司背景出身的读者来说，这种BDFL模式可能比较陌生。
在公司环境下，设计决定通常是由委员会决定的，重大的规则设立和改变都需要走一趟繁文缛节的官僚流程。
相反，不受直接监督，在不同的领域里，会诞生这么一小群专家：他们有能力独立行动，擅长产出高质量代码。
在必要的时候，这种简单构架可以令流程更加敏捷。
更重要的是，能够提高和维护框架内部的一致性。

在Python领域里，Python的创始人吉多·范罗苏姆（Guido van Rossum），就在BDFL这个位置上。
至于Django，有两个人在这个位置上，头衔是co-BDFL。
他们分别是，框架的联合创始人Adrian Holovaty，和目前Django的开发领头人Jacob Kaplan-Moss。
这一章的原则和哲学，也代表了BDFL们的思路和理想。

新闻和资源
---------

在一个像Django那么有激情和活力的社区里，我们有很多重要的事情要做，看看别人在干些什么，他们是怎么解决一些常见问题的，是不是有什么新应用出来了，等等。
考虑到社区的大小和多样性，很多人以为跟上它的步伐是一个艰巨的任务，但其实这很简单。

第一件事是关注Django的博客 [#f4]_ ，官方新闻会在这发布，里面包含了很多关于Django的新闻和更新，框架的开发进度，还有它被用到什么重要的地方。
例如，Django博客会发布新版本，近期的开发计划，项目的网站更新。

更重要的是这里有Django社区的新闻聚合 [#f5]_ ，收集了全世界开发者的文章，把他们展示在一个地方。
这里的文章都是由社区成员产出的，各式各样，丰富多彩，成为了一项非常有价值的资源。
内容可能会包含新发布的应用和更新，解决常见问题的窍门还有技巧，投入Django怀抱的一些新网站。

可复用的应用
----------

Django有一个方面非常有价值，它专注于“基于应用的开发”。
开发者应该根据不同的用途，来开发各个应用模块，再把这些模块组合起来创建网站，而不是每次创建网站都从零开始。
这种开发哲学鼓励社区成员开源他们写的应用，发布给大众，使得其他人可以从中受益。
开发者可以自由地选个地方存放他们的应用，但很多人都选择了GitHub [#f6]_ 。
原因是Github功能丰富，在开发者社区中很活跃，很多开发者都在使用它。
事实上，Django代码就是放Github的。
GitHub集成了它自己的问题跟踪系统（issue-tracking system），方便在同一处地方维护所有东西。
很多应用 [#f7]_ 都在那存放自己的代码，所以当你寻找自己需要的东西时，请花几分钟去Github找找，可能已经有人做出来了。
你也可以到Django Packages [#f8]_ 寻找和比较第三方应用。

毕竟，开源软件的一个主要目标是：一个大的社区比一个只有专职开发者的小团体，可以产出更好、更干净、功能更强大的代码。
Django社区展示了这个行为并且鼓励其他人利用这个优势。

获取帮助
-------

书本能够记录的知识是有限的，即使所有的书本加起来（包括本书），也不可能囊括所有场景下发生的问题。
再说，不是总能方便找到文档，即使找到文档你也不一定能看得懂。
这时候，你会发现，你需要找到一个有实操经验的人来帮助你。
你把发生问题的场景告诉他们，希望他们可以定位到问题并给出解决方案。

首先你得明白，*这并不是一个障碍* 。
任何人都可能遇到一个意料之外的场景，连我们当中最聪明最优秀的人，都有可能被简单的语法错误所迷惑。
如果这发生了在你身上，而你又需要帮助的时候，不妨大胆请求别人的帮助，你会发现Django社区是很友善的。

阅读文档
^^^^^^^

尝试解决任何问题的第一步，阅读官方文档！
官方文档内容应有尽有。类似，新功能的添加，现有行为的修改，这些都会定期更新。
当运行程序出现错误时，翻看文档确认一下，你有没有遵从Django的指引去做。
假如你的代码确实遵从文档的指引，那就检查下是否其他的常见问题。

检查你所使用的版本
^^^^^^^^^^^^^^^^

正如前面所提及到的，官方文档对应的是Django的主线开发。
所以出现文档的描述与你现有代码行为不一致，是很有可能发生的。
使用一个官方发布的正式版，会比较容易发生这个问题。
但即使你是追踪使用开发版的代码，这种情况依然会出现，这依赖于你有多频繁更新你的本地代码。
（编者注：使用什么版本就看相应版本的文档。你在使用正式版的时候又去看开发版的文档，那当然会出问题，摔！）

当你追踪主干分支代码时，你必须阅读官方文档中，关于向后不兼容 [#f9]_ 的那部分文章。
如果你更新之后发生了问题，确保你所使用的特性没有在此更新中发生过改变。

Q&A
^^^^

几年来，Django社区日常回答了各种各样的问题。
为了更方便地回答这些问题，诞生了两篇文章。（译者注：哪两篇？原文又没给出）
尽管官方FAQ [#f10]_ 收集了很多问题（不包含争议话题），但我们依然有几个公共的问题列表。
IRC频道有他自己的FAQ [#f11]_ 和问答集。

邮件列表
^^^^^^^

你可以很方便地在django-user邮件列表 [#f12]_ 提出你的问题。
邮件列表是通过普通电子邮件来运行的，他会把问题发给每一个人，而不需要其他特定软件。
简单加入列表后，你可以发表你的问题，成千上万人就会收到你提的问题。
没有人可以保证，但大部分的问题都会得到及时的回答。

使用邮件列表的一个突出优点是，它所有的对话都是存档的，方便以后参考。
作为FAQ的补充，当你尝试跟踪一个问题时，它有可能是其他人以前遇到过的，这时django-user邮件列表就是一个无价之宝了。
确保你在发问之前已经搜索过存档，因为很有可能其他人之前也遇到过。

IRC聊天频道
^^^^^^^^^^

如果你需要更快的回答，最好的选择就是Django的IRC频道 [#f13]_，在那里有很多知识渊博的Django社区成员直接跟你对话。
这是一个非常有用的地方，但你应该准备好问题的有关细节。
这个细节可能包括，所有的出错回朔栈（error traceback），模型视图的代码片段，还有其他可能跟问题有关的代码。

我们经常会使用一个在线工具 *pastebin* 来分享代码，这个工具可以粘贴临时代码，以供其他人查看。
我们会把代码临时贴到一个公共的网站，以分享给别人。
GitHub为此也提供了一个工具 *gitst* [#f14]_，可以跟IRC或者其他地方的用户分享代码。

接下来干嘛?
---------

当然，学习有关哲学和社区的知识，并不能教到你写任何的代码。
这些知识教你该怎么使用好工具，虽然这些工具还没有实际用得上。
下一章概况了很多Python提供的，但我们平时又很少接触到的工具。
再余下的章节，我们来探索Django的各种工具集。


.. rubric::
.. [#f1] http://prodjango.com/pep-20/
.. [#f2] http://prodjango.com/pep-8/
.. [#f3] http://prodjango.com/design-by-contract/
.. [#f4] http://prodjango.com/django-weblog/
.. [#f5] http://prodjango.com/community/
.. [#f6] http://prodjango.com/github/
.. [#f7] http://prodjango.com/github-projects/
.. [#f8] http://prodjango.com/djangopackages/
.. [#f9] http://prodjango.com/backwards-incompatible-changes/
.. [#f10] http://prodjango.com/faq/
.. [#f11] http://prodjango.com/irc-faq/
.. [#f12] http://prodjango.com/django-users/
.. [#f13] http://prodjango.com/irc/
.. [#f14] http://prodjango.com/gist/









