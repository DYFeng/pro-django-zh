理解Django
**********

埋头写代码是不够的。
代码虽然是由计算机来运行，但终究是由人来编写的。
写程序的人必须坐下来好好思考几个问题：
应该添加哪些功能，这些功能应该怎么实现，有哪些软件可以加以利用，为了未来的扩展性应该怎么添加钩子。
很多人往往追求结果，而忽略过程，噼里啪啦地开始敲键盘码字。
但一个成熟的程序员，对于自己做的每一个决策都是深思熟虑的。

使用一个类似Django的框架，很多类似的决策其实已经制定好，框架还对每种决策提供了相对应的工具。
在你自己的代码中，使用这些设计哲学。
不但可以使你跟Django还有其他的应用保持一致，你还会感叹自己构架出来的东西是多么的惊艳。

即使是最简单的代码背后，也蕴含着创作的思考过程。
它应该实现什么功能，怎么来实现这些功能，这些都是决策所需要考虑的问题。
在很多书和编程手册里，这个思考的过程往往被忽略掉。
这导致了一大群技术人员埋头苦干，仅仅为了完成手头上的任务而编程，而不是放眼未来。

本书剩余部分会详细介绍，Django支撑复杂项目的很多基本构件(basic building block)，但这一章会专注于框架基础原理的方方面面。
对于从其他背景过来的读者，这一章可能显得格外陌生，但这并不意味着这章不重要。
所有从事Python和Django的程序员，都应该对Django的设计理论有着扎实的理解，并且能够把这套理论运用到其他项目中去。

你可能想要反复阅读这一章，并且在使用Django的过程中经常翻阅。
在Django社区里，这章的很多观点已经是常识。
如果你打算与其他人协作，你必须仔细阅读此章，否则被人鄙视就不好了。


哲学
====

Django非常重视哲学的运用，这点体现在Django的代码和构架当中。
在编程领域里，这不是什么新鲜事，但初学者经常会身陷泥淖。
维护一致性和质量是基本要求，在维护的过程中，我们有一系列基本理论来帮助我们决策。TODO:这句话没翻译通。
这些理论对于独立程序，甚至程序集，也同样地重要，好好把握这些设计哲学，也会有类似的效果。

Tim Peters写的这段Python哲学，也许是最广为人知，被引用最多的。
Tim Peters长时间来是Python界的领军人物，写下了大量理论指导Python自身的开发进程。
这短短19行小诗，被称之为Python之禅(Zen of Python)。
在Python程序员中影响力甚远，被写入 PEP20 [#f1]_ 作为永久纪念。
还写入了Python标准模块--“彩蛋”模块this。

.. rubric::
.. [#f1] http://prodjango.com/pep-20/


.. code-block:: pycon

    >>> import this
    The Zen of Python, by Tim Peters

    Beautiful is better than ugly.
    Explicit is better than implicit.
    Simple is better than complex.
    Complex is better than complicated.
    Flat is better than nested.
    Sparse is better than dense.
    Readability counts.
    Special cases aren't special enough to break the rules.
    Although practicality beats purity.
    Errors should never pass silently.
    Unless explicitly silenced.
    In the face of ambiguity， refuse the temptation to guess.
    There should be one-- and preferably only one --obvious way to do it.
    Although that way may not be obvious at first unless you're Dutch.
    Now is better than never.
    Although never is often better than *right* now.
    If the implementation is hard to explain， it's a bad idea.
    If the implementation is easy to explain， it may be a good idea.
    Namespaces are one honking great idea -- let's do more of those!

虽然其中有部分明显是诙谐之句，但他很好地总结了Python的特性。
这章剩余内容会标记一些经常被Python社区引用的哲学，但所有的专业Python程序员都会把这段小诗永记于心，并且经常引用。

有一点请你必须记住，Python之禅里面很多内容都是非常主观的。
例如：“优美”比“丑陋”好，但“优美”的定义是因人而异的。
同样的道理，对于“简单”和“复杂”，“实用性”和“纯洁性”，每个开发者在认识上其实都有偏差。


Django对MVC模式的演绎
-------------------

MVC模式是其中一种被广泛应用的软件构架，它清晰地分割了一个软件各个重要部分的任务和责任。
Django只是轻度借鉴了这种构架。
我们不对MVC作过多讨论，而直接来看看它各个部分的概述。

- 模型，负责管理数据和核心业务逻辑。
- 视图，向用户展示数据。

控制器接收用户的输入，并在应用里执行相应的业务逻辑。
在很多领域里，MVC模式已经证明为非常高效。
但从创建Django之初，Django的创建者们就不想直接套用现有的任何构架模式。
他们只是想寻找一种简单高效的方式来开发Web软件。
毕竟，Django创建之初的目的，是为了满足报社的日常工作，需要快速跟得上需求的更改。
最终，因为不同的需求而把任务分割成不同的模块。

- 为了一系列特定任务而写的代码非常好维护，因为它不需要假设程序还有其他的无关部分。
  一般而言，这种观点叫“关注点分离”(separation of concerns)。而且在整个软件开发过程中，这种方法是适用的。
- 应用开发变得更加灵活，多个不同的视图层和控制器层，可能都是连接到同一个模型层。
  这允许不同的应用，可以共享相同的业务逻辑和数据。让关注不同部分的各个人，都能有不同的途径进行交互。
- 开发者只需要学习自己使用到的相关部分，而不需要把整个系统都过一遍。
  这特别有助于减轻挫败感和疲劳，让开发者可以在自己的领域里培养创新和成功。

当然使用MVC模式还有其他的小优点，但这些是它的主要优点。
需要注意的是，在MVC模式里进行这种划分，其主要的好处是可以把多个应用插入到同一个模型层。
剩下的唯一好处是，可以基于开发计划，来进行任意划分各个部分。

Django开发者把握这些MVC的优点，但更加专注于快速开发，为他们的工作流程创造了一系列靠谱的工具。
最终，他们创造了一种新的模式:模型-模版-视图(MTV)。
但事实上，一个Django应用是分为了四个主要组成部分，我们下面会详细讲述。

模型
^^^^^

考虑到把模型从应用中分离而带来的好处，Django严格继承了MVC模式中的M。
Django模型提供了一套便捷访问底层数据储存的机制，而且可以封装一些公共的常用核心业务逻辑。

模型的存在依赖于系统的其余部分。
模型设计的目的，就是给那些能够访问到他的应用使用。
事实上，我们可以直接从交互命令行(interactive interpreter)，利用模型实例来完成对数据库的操作，而不需要加载一个Web服务或者任何应用逻辑。

在第三章会对Django的模型作更详尽的讲解，包括他们是怎么被定义和利用，怎么嵌入到你的业务逻辑，等等。

Django视图跟传统MVC定义的视图只是名字一致，Django视图比传统范式包含了更多的东西。
Django视图，把传统视图的一些功能，和整个控制器的功能融合在了一起。
本文下面的视图，没有特别指代的，默认为Django视图。
视图接受用户的输入(包括一些简单的请求信息)，根据应用的交互逻辑来设定视图的行为。
再根据不同的用户场景，展示出模型渲染的数据。

视图通常是一个普通的Python函数，当用户请求一个特定的URL时会被调用。
根据Web协议(HTTP协议，译者注)，即使是一个简单的信息请求，也会被视为一个动作，所以视图需要处理数据修改以及其它提交。
为了完成用户发起的请求，视图必要时可以访问模型，进而获取和更新信息。

由于视图可以像一个简单的函数似的被调用，没有用到什么特殊的结构，所以视图可以有很多种方式来实现。
不仅仅可以是一个简单的函数，一个视图可以表现为任意Python回调，包括类，类实例方法(instance method)，可调用对象(callable object)，
加里化(curry)函数，装饰过的函数(什么是curry，看http://www.vaikan.com/currying-partial-application/和https://mtomassoli.wordpress.com/2012/03/18/currying-in-python/)

模版
^^^^

技术上，视图负责把数据呈现给用户。
可 *如何* 展示数据呢?这个任务一般来说分配给了模版。
模版在Django的开发中实在太重要了，以致他被分离成独立的一层。
由于模版负责了所有用户能看到的展示效果，很多人认为Django模版等同于传统的视图层。

Django已经提供了一套简易的模版语言，模版设计师不需要为了做模版而去学习Python。
Django模版语言不基于任何特定的描述性语言。
Django模版主要用来生成HTML，但他也可以生成任意基于文本的其他格式。

牢记，这个模版引擎不仅仅用来渲染可阅读的页面。
很多时候，视图可以使用HTTP重定向到其他URL，第三方PDF库，或者其他用来生成他们输出的东西。

URL配置
^^^^^^

作为一个Web框架，Django提供了一个独立的胶水层，通过访问不同的URL可以向外界展示不同的视图。
通过提供正则表达式作为URL组件，一条正则表达式可以囊括非常多的URL。
这种方式可读性高而且方便维护。

这个URL配置单独定义，与视图分离，使得一个视图可以对应多条URL，每个地址还可以有不同的选项。
事实上，Django其中一个核心就是，普适视图的理念(concept of generic views)。
这些视图的目的在于可以公用，使用一些配置选项令到它们适用于任何应用，只需要添加一条URL配置来激活它。

可能最重要的一点是，把URL作为单独的一个部分，能够激励开发者把URL纳入应用整体设计的一部分。
由于他们必须用在书签，博客文章，营销活动中，有时候URL的曝光率比你的应用还多。
毕竟，用户浏览网页，在他们决定是否访问你的网站之前，看到的是你的URL。
当使用印刷媒体进行广告营销时，URL就更显得重要了。

第四章将详细讲述了URL配置，包括一些关于设计合适URL的指导。

松耦合(Loose Copling)
------

MVC构架，或者是Django这个轻微修改后的构架，有一个很关键的概念:功能上有着显著区分的各部分部件，它们不应该依赖其他部分的运行。
这叫松耦合。
紧耦合(tight coupling)与此相反，它的模块经常严重依赖于其他模块实现的内部细节。

紧耦合会令到那些维护周期长的代码产生大量的问题:对于一个模块的重大改变，会不可避免地影响到其他模块。
这给程序员带来大量额外工作，当所依赖到的代码发生变化时，他就不得不作一些相应的修改以适应变化。
这些额外工作不仅影响到了程序员，对雇主来说也是一个很大的负担。
紧耦合很难把独立的行为分离出来，令到测试变得更加困难。

看上去，松耦合提倡，任何代码都不应该知晓其他代码的存在。
但是这样子的程序基本上是什么也干不了的。
某些代码模块总会不可避免地引用到其他的模块。
关键在于实现的时候，这个依赖应该越小越好。

在Python世界，我们有很多种方式实现松耦合，下面列出来其中一些来。
还有无数种其他的方法，足以写满一本书，但是这些技术点将会在第二章详细讲述

- 鸭子类型(Duck typing)
- 运算符重载(Operator overloading)
- 信号和调度(Signals and dispatching)
- 插件(Plugins)

Don't Repeat Yourself(DRY原则)
----------------------------

如果你已经尝试自己写过几次代码，你就会知道写“样板”代码是多么地容易。
你的代码一次只写一个功能，然后继续写下一个功能，下一个功能，下一个功能。
你过了一会就会发现，你写的代码是多么地重复。
幸运的话，你可能会有愉快的心情和时间精力，来分析哪些代码是可以挪到公共模块的。

这个过程就是框架存在的其中一个主要原因。
框架提供了很多公共方法，令到你可以避免在将来再去写重复的代码。
以上，展示了一个脍炙人口的编程实践：Don't Repeat Yourself

经常缩写为DRY，我们经常会在对话中用到这个词，例如:

- 作为名词--"这代码违反了DRY原则"
- 作为形容词--"我喜欢那个实现，这很DRY"
- 作为动词--"我们把他DRY一下吧"

DRY原则的基本要求是，对于同样的代码你只写一次。
相同功能的代码你重复写到了两处地方，当需要修改代码时，你漏改一处代码就会引起不一致的风险。
而且应该尽可能做到复用，当其他代码需要感知你写好的代码，你应该利用Python来自动获取必要信息，而不需要程序员去重复这个动作。

为了能够做到这点，Python提供了很多途径来检视你的代码，此过程称之为内省(introspection)。
在第二章将详细讲解，这对你代码DRY时非常有用。

专注可读性
---------

在之前的Python之禅也提及过，"Readability counts." 。
这可能是Python最重要的特性之一。
事实上，Python语言本身及产出代码都具备很高的可读性，令到很多Python程序员自以为豪。
其思想是，人们阅读代码的频次要比写代码的频次高得多。在开源世界这种情况更甚。

Python提供了很多特性来提高其可读性。
比如，它尽可能少用标点和强制缩进，在语法层面提高你代码的可读性。
当你实际写代码时，还有需要考虑更多的因素。

为了提高代码的可读性，Python社区就代码风格编写出了一套指南。
正如PEP-8写的那样，这套指南不仅是为了提高某个程序的可读性，更重要的是保持了不同程序之间的一致性。
当你看一个书写良好的程序很有感觉时，其他的程序也就能举一反三了。

我们就不在这细说PEP-8，它内容太多了，强烈建议读者通过阅读它来学习怎么写好代码。
有一点要注意的是，当你阅读Django的源代码，就会发现它并没有完全遵从PEP-8。
讽刺的是，假如你严格准守PEP-8的每条规则，有时候反而会导致一些问题。
总言而之，再次引用Python之禅，"Practicality bests purity"(译者注：不要为了保持代码的“纯洁性”，而忽略了实际的需要)。
本书的所有例子会遵从Django的源代码风格。

大声报错(Failing Loudly)
----------------------

"Errors should never pass silently. / Unless explicitly silenced." (译者注：错误永远都不应该沉默，除非你显式指定他沉默)
这看似是一句简单的感情告白，只有短短两行，却占据了Python之禅十分之一的篇幅。
在Python里这两句话说得尤其正确。
所有的编程语言都会产生错误，大部分语言可以优雅地处理错误。
不同语言对于处理错误有不同的最佳实践。

你需要记住一个关键点:大部分Python异常的名字都是以Error结尾的，但基类的名字却叫Exception。
我们首先要学习的点是:为什么要使用这个特别的单词(Exception),从而学习怎么处理和使用异常。
在一些字典里查找单词"exception"，可以看到很多种解释。
(译者注:不知道原作者从哪找到的解释,译者还没牛逼到翻译字典的地步,下面解释是从牛津英汉词典找的)

- 一般情况以外的人(或事物); 例外
- 规则的例外; 例外的事物

比起错误，异常更像是一种场景描述:当一些没预见的事情发生了，异常描述了这个问题发生的场景。
这其中有着微妙的区别，某些人却把异常看待成错误，把异常当作是不可恢复的错误，例如损坏的文件或者是网络失败。
他们还会举出一些事实依据，在一些语言中，抛出异常的代价非常昂贵，为了避免性能问题，异常在任何时候都要避免。

在Python里，抛出一个异常的代价,并不比简单返回一个值更昂贵。
所以,让异常更加贴近它字典所定义的吧。
假如我们定义一个异常，是因为它违反了某条规则，显而易见,我们必须先得定义这条规则。

定义规则

要想把异常理解透彻，这是最重要的一个点。而且头脑必须清楚一点:自古没有定义这些规则的Python语法。
这已经超出了语言范畴。
有一些语言，显式支持契约式设计(design by contract，也就是DbC)，还有很多语言是通过框架级的代码来实现，但Python原生不支持定义这些规则。

反而，程序员会根据他们代码的需要,来定义这些规则。
这看上去好像过分简化了，其实不然。
代码应该严格遵从作者的意图，不做多余的事情。
任何不在程序员意料中发生的事情，都应该被视为异常。
举例说明这点，下面是Python和Django的一些规则:

- 访问列表(list)的某个元素，应该使用中括号语法(my_list[3])，返回列表某个位置的元素
- 集合(set)的discard()方法可以保证某一个元素不再是集合的成员。
- QuerySet的get()方法，根据传进的参数,返回单独的一个对象。

类似这样的规则很重要。
因为即使这些规则很简单，但他们精确地描述了在不同场景下这些功能的行为。(译者注:这些功能指的是,访问列表的某个元素,discard()方法,get()方法)
为了进一步举例说明，考虑以下场景，看看规则是怎么影响行为的。

- 我们给出一个索引位置,如果列表在该位置有元素存在，则返回相应的值。
  如果不存在，则抛出一个异常(IndexError)。
  如果使用的索引不是整形(integer)，则抛出另一个异常(TypeError)。

- 当使用discard()函数移除集合里的某个元素时，如果这个元素在集合内，则简单移除。
  如果这个元素不在集合内，discard()函数不会抛出一个异常，因为discard()只是保证这个元素不在这个集合内。

- 调用QuerySet的get()方法，如果在数据库里面找到相符的一条记录，那么这条记录就会被封装成相应模型的实例并返回。
  如果没有找到相符的记录，则抛出一个异常(DoesNotExist)。
  但如果有不止一条记录返回，则抛出另一个异常(MultipleObjectReturned)。
  最后，如果传进去的参数不能被用来查询数据库(由于类型错误，未知的属性名字或者其他原因)，则抛出异常(TyepError)。

明显，哪怕是最简单的规则也有其深厚的影响，从他们被显式定义开始一直影响至今。
作者需要清晰知道这些定义的规则，但如果不把这些规则传达给其他人，那这些规则就发挥不了其作用。
这点在一些诸如Django的框架中，尤其重要，因为他的开发是由大众来完成的。

文档规范
^^^^^^^

我们有很多种的方法来定义这些规则，每段代码都应该遵从这些规则。
通过不同途径,多个层次,来记录下这些规则是大有裨益的。
人们主要会从四个地方看到这些信息，假如你把文档放到这四个地方或者其中一个，都能让人看到你的文档。

- Documentation -- 他应该储存了这个应用的所有信息，合乎情理，这些规则都应该被包含在此。
- Docstrings -- 独立的注释文档，开发者经常会翻看代码，看看他是怎么工作的。
  Docstrings就是代码旁的文本注释,解释这段代码是怎么实现的。
- 测试 -- 除了解释这些规则给人类理解，我们也可以给Python解释这些规则。
  这可以让你的代码在一个基准场景中得以验证。
  除此之外，doctest，这是把测试写到docstrings里，对人类而言可读性也比较高，达到一箭双雕的效果。
- 注释(Comments) -- 有时候，一个函数实在太复杂了，在完整文档甚至docstring里找到的概述，都不能充分说明这一大段代码是用来干神马的。
  虽说Python注重可读性，遇到这种情况相当罕见，但我们仍然会遇到。
  这种情况下，注释有助于解释给别人听，这段代码目的是什么，从而知道什么情况应该被考虑为异常。
  尤其一点，注释应该解释代码的目的，而不是每一行代码实际在干什么。
  多想想 *为什么* ，而不是 *做什么*。

不管你用什么方法来描述你的规则，第一件事你必须记得:显式定义。
记住，任何在你规则之外的情况，都应该被视为异常。
所以,显式定义你的规则,有助于你编码的时候决策:不同的场景下，你的代码应该有怎样的行为，包括应该在什么时候抛出异常。

还有一点:保持一致性。
很多类和函数，名字或者接口看上去都差不多，那不管他们在什么地方，他们的行为都应该是类似的。
程序员总是想在类似的组件上，获得类似的使用体验。
你最好是满足他们的欲望罗。
所以你在写代码的时候，最好就模仿Python或者Django里面的套路。
这些套路已经有很好的文档,而且广泛被程序员所接受。

社区
====

自2005年向外发布后，Django在技术上和文化上都获得了巨大的成功。
在Python Web开发的爱好者和专业人士中,Python积累了一大批粉丝。
这个社区对于框架还有他的用户而言，是一项最伟大的财富。
一些细节我们值得继续讨论。

.. seealso::
  一个进化中的社区
  意识到Django社区像任何一个社会结构一样，一直在进化和改变，这是非常重要的。
  所以这章的内容，可能已经不能准确地反映社区此时的实践和期望。


没有理由因此而阻挡你前进的脚步。
有一件事我最希望能够一直传承下去:社区乐意去拥抱新成员。
只要你愿意把自己泡在那，你总是可以接触到大量的人。

框架的管理
---------


对于Django的开发，还有Python的开发，你需要知道的第一件事就是:框架的代码是每个人都可以查看和修改(毕竟他是开源的)，但对核心的全权管理是由一小部分人监控的。
有权限更新主代码仓库的人组成了这些"核心开发者"。

何谓"核心"?

Django是开源的，所以任何人都可以修改Django的代码,并发布这些修改过后的版本。
很多开发者已经在这么干了，添加一些有意义的特性和增强功能，再把他们的成果分享给其他人。
一些高级使用者可以对核心代码做一些非常重大的修改，而不会影响到那些没有用到这些特性的使用者。

此外，允许和鼓励开发者把他们的应用做得更加通用，然后把应用分发给其他人。
这些应用传播得越来越广泛,使得他们在新项目开始的时候,就把这些应用默认加入。

比较起来，Django的核心，仅仅是在Django主站分发的代码而已，比如一个官方的发布，或者源代码开发主分支。
所以当讨论甚至争论是否应该把一些东西加入核心时，其争议是:应该把他加入官方的发布中呢?还是当作第三方资源，譬如一个分支或者是一个分发的应用。

有一个有趣的灰色地带:django.contrib包。
它被包含在Django主发行中，是核心的一部分，但它们是被设计成第三方应用来使用。
其意义是，当一个第三方的应用写得足够好，在社区里获得了足够的吸引力,并且承诺会持续支持下去，最终他就会被加入到核心。
可事实上，他们经常会走向另一条路，从核心删除django.contrib包，作为第三方应用维护下去。

这种结果有助于保证，那些对框架最有经验的，他的历史可查找的，经常调整的，在他们别提交到源码库之前的补丁。
他们也经常对最近框架的开发问题进行讨论，还有讨论一些需要完成的大修改和重要改良，等等。

但仍然有人是站在管理链的最顶层。
这个职位叫 仁慈的独裁者(Benevolent Dictator for Life)，缩写为BDFL。
处于这个职位的人,对于所有决定有着至高无上的权力，他需要打破平局，或者推翻大多数人的决定。
幸运的是，他们真的是"仁慈的"独裁者，不会轻易地做出决定。

事实上，BDFL这个主意，非常的幽默诙谐。
虽然他们拥有无限的权力，但这个权力很罕见会被使用，因为他们会听从群众的意见。
当他们需要干涉并仲裁一个决定的时候，他们裁定的依据是这么多年来，知道什么是对框架和听众最好，的经验。
事实上，他们经常会向群体详细描述他们的主意，如果有合理的争议，甚至可能屈服于群体。


这种BDFL的方式，可能对于那些公司背景出来的读者来说比较陌生，公司环境下，设计决定通常是由委员会决定的，重大的规则和改变需要走一趟详尽的官僚流程。
反而，在不同的领域里，一小群的专家经常是不受监管的，他们在表现独立，开发出高质量的代码上非常厉害。
这种简单的结构会使流程在必要的时候走得非常快，更重要的是，在框架内帮助维持更高的一致性。


在Python领域，Guido van Rossum，Python的创始人，就在BDFL这个位置上。
至于Django，这个位置上有两个人，头衔是co-BDFL，Adrian Holovaty，框架的联合创始人，还有Jacob Kaplan-Moss，目前Django的开发者带头人。
贯彻这一章的原则和哲学，其实是BDFL们反映的意见和理想，他们说要写的。

新闻和资源
---------
在一个像Django那样有激情和活力的社区，很重要的是，看看别人都在干嘛，对于一些普遍问题他们是怎么解决的，新应用出来了，还要很多其他事情
考虑到社区的大小和多样性，跟上他，似乎是一个使人畏缩的任务，但他其实非常简单。

第一件事就是，留意Django的博客，这是官方新闻放出的地方，包含了很多关于框架本身的新闻和更新，框架的开发还有他被使用到什么重要的地方。
例如，Django博客会发布新release，即将来临的开发计划，项目网站的更新。

可能更重要的是Django社区的新闻聚合，这里收集了全世界开发者的文章，把他们都在一个地方展示。
这里信息的多样性更加丰富多彩，因为他是由社区成员生产的，使他成为了一项非常有价值的资源。
内容可能会包含新的和更新的应用，解决大家问题的tips还有技巧，使用到Django的新网站。



可复用的应用
----------

Django其中一个最有价值的方面就是，他的开发专注于"应用"，而不是自己在那空想，是基于应用的需求来开发框架的。
比起从头创建每一个网站，开发者更应该为一些明确的用途来开发应用模块，然后把这些模块组合在一起创建网站。
这种哲学激励很多社区成员把他们写的应用作为开源向大众发布，使得其他人可以从他们的功能里获益。
开发者是很自由地放置他们的应用，想放哪放哪，但是很多人都选择GitHub，因为Github功能丰富，在开发者社区很活跃，就是很多开发者用他。
事实上，Django代码就是放那的。
GitHub集成了他的问题跟踪系统，使得很方便在一个地方维护所有东西。
很多应用在寄放在那，所以很值得你话几分钟去找找有没有人已经写出了你所需要的东西。
你也可以在Django Packages寻找和比较第三方应用。

毕竟，开源软件有的一个主要目标是:一个更大的社区比一个只有专注开发者的小团体，可以产生更好、更干净、功能更强大的代码。
Django社区展示了这个行为并且鼓励其他人利用这个优势。

获取帮助
-------

尽管所有的知识在这本书内，还有其他书内，也不能假装能超前记录任何的情景下的问题。
再说，文档不是总能容易找到或者看得懂。
在这些情景下，你会发现你自己需要把你的场景告诉给其他活生生的人，那些人有现实世界的经验，期望他们可以定位到问题并给出解决方案。

第一件事你需要知道的是，这并不是一个问题。
任何人都可能嵌入一个不在意料之中的场景，甚至我们当中最聪明最好的人，都有可能被简单的语法错误所迷惑。
如果这发生了在你身上，你要知道其实Django社区是很好人的，当你需要的时候，你可以请求别人的帮助而不用害羞。

阅读文档
^^^^^^^
尝试解决任何问题的第一步，都应该是先阅读官方文档。
官方文档非常彻底，定期更新，新功能的添加，现有行为的改变，都会在上面的了。
当运行程序出现错误，文档可以帮助你确定，你有没有按照Django期望的方法去做。


当你的代码跑起来符合文档的展示，那是时候去看看其他的公共问题。





检查你所使用的版本
^^^^^^^^^^^^^^^^
正如前面的提及到的，官方文档是跟上Django的主线开发的，所以肯定会可能出现文档的功能，跟你正在用的代码功能不一致。
如果你使用一个官方的版本，这更加不容易发生，但如果你是跟踪使用主干代码这依然会发生，这依赖于你多频繁更新你的本地拷贝。

当你追踪主干分支，有关向后不兼容的改变的文章，应该作为你必看的官方文档部分。
如果你更新了之后发生问题，确保你使用的功能，都没有在这次更新发生过改变。



Q&A
^^^^
在几年时间回答问题中，Django社区在日常听到了各种各样的问题。
为了更方便地回答这些问题，诞生了两篇文章。
尽管官方FAQ包含了很多问题，但仍然有几个公共的问题列表在那。

IRC频道有他自己的FAQ和问题回答集合。

邮件列表
^^^^^^^
其中一个非常方便问你问题的地方就是django-user邮件列表
因为他是通过标准邮件来运行的，所以他会发给每一个人，不需要其他特定的软件。
简单加入列表后，你可以发表你的问题，上千的其他人就会看到。
虽然没有任何保证，但大部分的问题都会得到快速的回答。

邮件列表的一个关键优势就是，他所有的对话都是存档的，以便以后参考。
作为FAQ的补充，当你尝试跟踪一个可能是其他人以前遇到过的问题时，django-user邮件列表是一个无价的资源。
确保你在问你问题之前已经搜索过存档，因为很有可能其他人之前也遇到过。



IRC聊天频道
^^^^^^^^^^

如果你需要更快的回答，最好的选择就是Django的IRC频道，那里有很多知识渊博的Django社区成员，可以直接跟你对话。
这是一个非常有用的环境，但你应该准备好这个问题的有关细节。
这可能包含所有的出错回朔栈，模型的代码片段，师徒，还有其他可能跟问题有关的代码。

代码经常会使用一个在线的工具pastebin来分享，这个地方可以临时放置代码，以供其他人查看。
代码可以短时间内贴到一个公共的网站，允许分享给其他人。
GitHub为了这个目的提供了一个工具，叫gitst，他是一个可以跟IRC或者其他地方的用户分享代码的工具。


接下来干嘛?
---------

当然，学习有关哲学和社区的知识，并不能教到你写任何代码。
他教你怎么使用好工具，但这些工具还没有实际地用得上。
下一章概况了很多平时很少用上的有用工具，有Python自己提供的，再后面的所有章节，我们来探索很多Django自己的工具集。










