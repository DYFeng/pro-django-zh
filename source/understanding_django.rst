理解Django
**********

埋头写代码是不够的。
代码虽然是由计算机来运行，但终究是由人来编写的。
写程序的人必须坐下来好好思考几个问题：
应该添加哪些功能，这些功能应该怎么实现，有哪些软件可以加以利用，为了未来的扩展性应该怎么添加钩子。
很多人往往追求结果，而忽略过程，噼里啪啦地开始敲键盘码字。
但一个成熟的程序员，对于自己做的每一个决策都是深思熟虑的。

使用一个类似Django的框架，很多类似的决策其实已经制定好,框架还对每种决策提供了相对应的工具。
在你自己的代码中,使用这些设计哲学。
不但可以使你跟Django还有其他的应用保持一致,你还会感叹自己构架出来的东西是多么的惊艳。

即使是最简单的代码背后，也蕴含着创作的思考过程。
它应该实现什么功能,怎么来实现这些功能,这些都是决策所需要考虑的问题。
在很多书和编程手册里，这个思考的过程往往被忽略掉。
这导致了一大群技术人员埋头苦干，仅仅为了完成手头上的任务而编程，而不是放眼未来。

本书剩余部分会详细介绍,Django支撑复杂项目的很多基本构件(basic building block)，但这一章会专注于框架基础原理的方方面面。
对于从其他背景过来的读者，这一章可能显得格外陌生，但这并不意味着这章不重要。
所有从事Python和Django的程序员，都应该对Django的设计理论有着扎实的理解，并且能够把这套理论运用到其他项目中去。

你可能想要反复阅读这一章,并且在使用Django的过程中经常翻阅。
在Django社区里，这章的很多观点已经是常识。
如果你打算与其他人协作，你必须仔细阅读此章，否则被人鄙视就不好了。


哲学
====

Django非常重视哲学的运用，这点体现在Django的代码和构架当中。
在编程领域里，这不是什么新鲜事，但初学者经常会身陷泥淖。
维护一致性和质量是基本要求，在维护的过程中,我们有一系列基本理论来帮助我们决策。TODO:这句话没翻译通。
这些理论对于独立程序，甚至程序集，也同样地重要,好好把握这些设计哲学,也会有类似的效果。

Tim Peters写的这段Python哲学，也许是最广为人知，被引用最多的。
Tim Peters长时间来是Python界的领军人物，写下了大量理论指导Python自身的开发进程。
这短短19行小诗，被称之为Python之禅（Zen of Python）。
在Python程序员中影响力甚远，被写入 PEP20 [#f1]_ 作为永久纪念。
还写入了Python标准模块--“彩蛋”模块this。

.. rubric::
.. [#f1] http://prodjango.com/pep-20/


.. code-block:: pycon

    >>> import this
    The Zen of Python， by Tim Peters

    Beautiful is better than ugly.
    Explicit is better than implicit.
    Simple is better than complex.
    Complex is better than complicated.
    Flat is better than nested.
    Sparse is better than dense.
    Readability counts.
    Special cases aren't special enough to break the rules.
    Although practicality beats purity.
    Errors should never pass silently.
    Unless explicitly silenced.
    In the face of ambiguity， refuse the temptation to guess.
    There should be one-- and preferably only one --obvious way to do it.
    Although that way may not be obvious at first unless you're Dutch.
    Now is better than never.
    Although never is often better than *right* now.
    If the implementation is hard to explain， it's a bad idea.
    If the implementation is easy to explain， it may be a good idea.
    Namespaces are one honking great idea -- let's do more of those!

虽然其中有部分明显是诙谐之句，但他很好地总结了Python的特性。
这章剩余内容会标记一些经常被Python社区引用的哲学，但所有的专业Python程序员都会把这段小诗永记于心，并且经常引用。

有一点请你必须记住，Python之禅里面很多内容都是非常主观的。
例如：“优美”比“丑陋”好，但“优美”的定义是因人而异的。
同样的道理，对于“简单”和“复杂”，“实用性”和“纯洁性”，每个开发者在认识上其实都有偏差。


Django对MVC模式的演绎
-------------------

MVC模式是其中一种被广泛应用的软件构架，它清晰地分割了一个软件各个重要部分的任务和责任。
Django只是轻度借鉴了这种构架。
我们不对MVC作过多讨论，而直接来看看它各个部分的概述。

- 模型,负责管理数据和核心业务逻辑。
- 视图,向用户展示数据。

控制器接收用户的输入，并在应用里执行相应的业务逻辑。
在很多领域里,MVC模式已经证明为非常高效。
但从创建Django之初,Django的创建者们就不想直接套用现有的任何构架模式。
他们只是想寻找一种简单高效的方式来开发Web软件。
毕竟，Django创建之初的目的,是为了满足报社的日常工作，需要快速跟得上需求的更改。
最终，因为不同的需求而把任务分割成不同的模块。

- 为了一系列特定任务而写的代码非常好维护，因为它不需要假设程序还有其他的无关部分。
  一般而言，这种观点叫“关注点分离”(separation of concerns)。而且在整个软件开发过程中,这种方法是适用的。
- 应用开发变得更加灵活，多个不同的视图层和控制器层,可能都是连接到同一个模型层。
  这允许不同的应用,可以共享相同的业务逻辑和数据。让关注不同部分的各个人,都能有不同的途径进行交互。
- 开发者只需要学习自己使用到的相关部分,而不需要把整个系统都过一遍。
  这特别有助于减轻挫败感和疲劳，让开发者可以在自己的领域里培养创新和成功。

当然使用MVC模式还有其他的小优点，但这些是它的主要优点。
需要注意的是,在MVC模式里进行这种划分,其主要的好处是可以把多个应用插入到同一个模型层。
剩下的唯一好处是,可以基于开发计划,来进行任意划分各个部分。

Django开发者把握这些MVC的优点，但更加专注于快速开发,为他们的工作流程创造了一系列靠谱的工具。
最终，他们创造了一种新的模式:模型-模版-视图(MTV)。
但事实上，一个Django应用是分为了四个主要组成部分，我们下面会详细讲述。

模型
^^^^^

考虑到把模型从应用中分离而带来的好处，Django严格继承了MVC模式中的M。
Django模型提供了一套便捷访问底层数据储存的机制，而且可以封装一些公共的常用核心业务逻辑。

模型的存在依赖于系统的其余部分。
模型设计的目的,就是给那些能够访问到他的应用使用。
事实上，我们可以直接从交互命令行(interactive interpreter)，利用模型实例来完成对数据库的操作，而不需要加载一个Web服务或者任何应用逻辑。

在第三章会对Django的模型作更详尽的讲解，包括他们是怎么被定义和利用，怎么嵌入到你的业务逻辑，等等。

Django视图跟传统MVC定义的视图只是名字一致，Django视图比传统范式包含了更多的东西。
Django视图,把传统视图的一些功能,和整个控制器的功能融合在了一起。
本文下面的视图,没有特别指代的,默认为Django视图。
视图接受用户的输入（包括一些简单的请求信息），根据应用的交互逻辑来设定视图的行为。
再根据不同的用户场景,展示出模型渲染的数据。

视图通常是一个普通的Python函数，当用户请求一个特定的URL时会被调用。
根据Web协议(HTTP协议,译者注),即使是一个简单的信息请求，也会被视为一个动作，所以视图需要处理数据修改以及其它提交。
为了完成用户发起的请求,视图必要时可以访问模型，进而获取和更新信息。

由于视图可以像一个简单的函数似的被调用,没有用到什么特殊的结构，所以视图可以有很多种方式来实现。
不仅仅可以是一个简单的函数，一个视图可以表现为任意Python回调，包括类，类实例方法(instance method)，可调用对象(callable object)，
加里化(curry)函数，装饰过的函数(什么是curry，看http://www.vaikan.com/currying-partial-application/和https://mtomassoli.wordpress.com/2012/03/18/currying-in-python/)

模版
^^^^

技术上,视图负责把数据呈现给用户。
可 *如何* 展示数据呢?这个任务一般来说分配给了模版。
模版在Django的开发中实在太重要了,以致他被分离成独立的一层。
由于模版负责了所有用户能看到的展示效果，很多人认为Django模版等同于传统的视图层。

Django已经提供了一套简易的模版语言，模版设计师不需要为了做模版而去学习Python。
Django模版语言不基于任何特定的描述性语言。
Django模版主要用来生成HTML，但他也可以生成任意基于文本的其他格式。

牢记，这个模版引擎不仅仅用来渲染可阅读的页面。
很多时候,视图可以使用HTTP重定向到其他URL，第三方PDF库，或者其他用来生成他们输出的东西。

URL配置
^^^^^^

作为一个Web框架，Django提供了一个独立的胶水层，通过访问不同的URL可以向外界展示不同的视图。
通过提供正则表达式作为URL组件,一条正则表达式可以囊括非常多的URL。
这种方式可读性高而且方便维护。

这个URL配置单独定义，与视图分离，使得一个视图可以对应多条URL，每个地址还可以有不同的选项。
事实上，Django其中一个核心就是,普适视图的理念(concept of generic views)。
这些视图的目的在于可以公用，使用一些配置选项令到它们适用于任何应用，只需要添加一条URL配置来激活它。

可能最重要的一点是，把URL作为单独的一个部分，能够激励开发者把URL纳入应用整体设计的一部分。
由于他们必须用在书签，博客文章，营销活动中，有时候URL的曝光率比你的应用还多。
毕竟，用户浏览网页,在他们决定是否访问你的网站之前，看到的是你的URL。
当使用印刷媒体进行广告营销时，URL就更显得重要了。

第四章将详细讲述了URL配置，包括一些关于设计合适URL的指导。

松耦合(Loose Copling)
------

MVC构架，或者是Django这个轻微修改后的构架，有一个很关键的概念:功能上有着显著区分的各部分部件，它们不应该依赖其他部分的运行。
这叫松耦合。
紧耦合(tight coupling)与此相反，它的模块经常严重依赖于其他模块实现的内部细节。

紧耦合会令到那些维护周期长的代码产生大量的问题:对于一个模块的重大改变，会不可避免地影响到其他模块。
这给程序员带来大量额外工作，当所依赖到的代码发生变化时,他就不得不作一些相应的修改以适应变化。
这些额外工作不仅影响到了程序员，对雇主来说也是一个很大的负担。
紧耦合很难把独立的行为分离出来,令到测试变得更加困难。

看上去，松耦合提倡，任何代码都不应该知晓其他代码的存在。
但是这样子的程序基本上是什么也干不了的。
某些代码模块总会不可避免地引用到其他的模块。
关键在于实现的时候，这个依赖应该越小越好。

在Python世界，我们有很多种方式实现松耦合，下面列出来其中一些来。
还有无数种其他的方法，足以写满一本书，但是这些技术点将会在第二章详细讲述

- 鸭子类型(Duck typing)
- 运算符重载(Operator overloading)
- 信号和调度(Signals and dispatching)
- 插件(Plugins)

Don't Repeat Yourself(DRY原则)
----------------------------

如果你已经尝试自己写过几次代码，你就会知道写“样板”代码是多么地容易。
你的代码一次只写一个功能，然后继续写下一个功能，下一个功能，下一个功能。
过了一会你就会发现,你的代码是多么地重复。
你幸运的话,可能会有愉快的心情和时间精力，来分析你的代码哪些是可以挪到公共模块的。

这个过程就是框架存在的其中一个主要原因。
框架提供了很多公共方法，令到你可以避免在将来再去写重复的代码。
以上，展示了一个脍炙人口的编程实践：Don't Repeat Yourself

经常缩写为DRY，我们经常会在对话中用到这个词，例如:

- 作为名词--"这代码违反了DRY原则"
- 作为形容词--"我喜欢那个实现，这很DRY"
- 作为动词--"我们把他DRY一下吧"

DRY原则的基本要求是,对于同样的代码你只写一次。
相同功能的代码你重复写到了两处地方,当需要修改代码时,你漏改一处代码就会引起不一致的风险。
而且应该尽可能复用，如果其他代码需要知道你已经写的代码，你应该能够利用Python自动获取必要的信息，而不需要程序员去重复任何信息。

为了达成此目标，Python提供了很多途径来检视你的代码，此过程称之为内省(introspection)。
这些途径会在第二章讲解，在你代码DRY的过程中非常有用。

专注可读性
---------

"Readability counts." 在之前的Python之禅也提及过，这可能是Python最重要的特性之一。
事实上，很多Python程序员都因为语言还有他们写的代码的可读性而沾沾自喜。
那是因为，阅读代码的频次要比写代码的频次高得多，开源世界更甚。


为了此目的，Python提供了很多增强可读性的功能。
比如，他使用标点和强制缩进，令到语言本身可以帮手维护你代码的可读性。
当你实际写代码的时候，这个会被考虑得更多。


现实中，Python社区已经开发了一系列代码风格指南，目的是为了增强可读性。
PEP-8的陈述，这些指南不但是为了某个独立程序的可读性而设立，而且是做到多个程序代码之间的一致性。
一旦你看懂了一个写得好的程序，你就很容易看得懂其他程序。

PEP-8的细节列在这里就太繁琐了，确保你自己通过阅读它，而明白怎么写好代码的理念。
而且有一点要注意的是，如果你阅读Django的源代码，你会发现里面并没有执行PEP-8的一些陈述。
讽刺的是，为了可读性，你严格准守PEP-8的每条规则，有时候会导致一些问题。
总言而之，再次引用Python之禅，"Practicality bests purity"。
本书的例子会跟随Django的源代码风格。



大声爆错(Failing Loudly)
--------------------
"Errors should never pass silently. / Unless explicitly silenced." 错误永远都不应该沉默，除非你显式指定他沉默。
这看似一句简单的感情告白，只有短短两行，却占据了10%的Python之禅，在Python里这尤其正确。
所有的编程语言都会产生错误，大多数都有优雅处理错误的方法，但每个语言都有他自己处理错误的最佳实践。


有一个关键你需要记住的就是，尽管大部分Python异常的名字都是以Error结尾，但基类叫Exception。
我们通过学习为什么这个特别的单词会被使用，来明白他们是怎么被使用和处理的。
在一些字典里查找单词"exception"，我们可以看到很多种解释。

- 一些被期待的事情，一个实例或者用户没有遵循标准规则
- 一个实例没有遵从规则或者标准化，他是被期待的
- 一个实例没有遵从规则或者标准化

比起一个错误，异常更像是当某些不期待的事情发生了，然后异常来描述问题发生的场景。
这看上去像一个微妙的区别，但有一些人却把异常看待成错误，把他们当做是不可恢复的错误，例如像损坏的文件或者是网络失败。
事实证明，在一些语言中，抛出异常非常昂贵，所以为了避免性能问题，异常在任何时候都要避免。


在Python里，异常不会比简单返回一个值要昂贵，让异常更加贴近他的字典定义吧。
如果我们定义一个异常，是违反了某条规则，显而易见，我们必须先定义这条规则。

定义规则

这对于明白异常来说，是一个最重要的方面，所以他必须清晰定义。
没有Python语法来定义这些规则。
这不是语言范围内的功能。
有一些语言，显式支持契约式设计(design by contract，aka DbC)，还有很多语言是通过框架级的代码来实现，但Python天生不支持这种方式。


反而，程序员根据他们代码的需要来定义这些规则。
这看上去好像过度简单化了，其实不然。
代码应该严格遵从作者的意图，不做多，不做少。
任何发生在编程者意图外的事情，都应该被考虑作为一个异常。
举例说明这点，下面是Python和Django的一些规则:

- 访问列表(list)的一个元素，应该使用中括号语法(my_list[3])，返回在列表特定位置的元素
- 集合(set)的discard()方法可以保证一个特定元素不再是集合的成员。
- QuerySet的get()方法，根据给的参数返回一个并仅且一个对象。

类似这样的例子很重要，因为即使这些规则很简单，但他们精确地描述了下面的功能在不同环境下的行为。
为了进一步举例说明，考虑以下场景，看看规则是怎么影响行为的。

- 如果列表所在索引有元素存在，则返回相应的值。如果不存在，会抛出一个异常(IndexError)。
  如果使用的索引不是整数形(integer)，则抛出另一个异常(TypeError)。

- 当使用discard()函数移除集合里的某个元素时，假如这个元素在集合内，那就简单移除。
  假如这个元素不在集合内，discard()函数不会抛出一个异常，因为discard()只是保证这个元素不在这个集合内。

- 假如调用QuerySet的get()方法，在数据库里面找到相符的一条记录，那么这条记录就会被封装成这个模型的实例并返回。
  如果没有相符的记录，则抛出一个异常(DoesNotExist)，但如果有不止一条记录返回，则抛出另一个异常(MultipleObjectReturned)。
  最后，如果传进去的参数不能被用来查询数据库(由于类型错误，未知的属性名字或者其他原因)，抛出异常(TyepError)。

明显，哪怕是简单的规则都有深厚的意义，从他们被显式定义开始一直流传至今。
尽管唯一的要求是，他被定义在作者的脑海里，如果不把规则传递给其他人，那规则就一无是处。
这一点在一些框架里，例如Django，变得特别重要，因为他的开发需要分发给大众。


文档规范
^^^^^^^
有很多恰当的方法来定义特定的规则，每段代码都应该遵从这些规则。
指定他们有多种途径，这是非常有用的，在多层次的复杂下。
人们会从四个主要地方看到这个文档，所以你把文档放到这四个地方或者其中任意一个，就能让人看到你的文档。

- Documentation--他应该完全收集了这个应用的所有信息，合乎道理，这些规则应该会被包含在此。
- Docstrings--单独的小文档，开发者经常会查看代码，看看他是怎么工作的。
  Docstrings 允许你在代码旁边写文本解释这段代码是怎么实现的
- 测试--除了提供这些规则的解释给人类理解，把他们提供给Python也能理解是一个非常好的主意。
  这可以让你的代码在一个普通的场景下可以得以验证。
  除此之外，doctest，这是把测试写到docstrings里，也比较对人类可读，达到一箭双雕的效果。
- Comments--有时候，一个函数可能因为太复杂了，以致在完整文档甚至docstring里找到的概述，都不能充分解析这一大段代码是用来干神马的。
  Python注重可读性，令到这种情况相当罕见，但他仍然会发生。
  但当他发生了，注释会有力帮助解释给其他人，这段代码的目的是什么，从而知道什么应该被考虑成是异常。
  尤其一点，注释应该解释代码的目的，而不是每一行代码实际在干什么，想为什么，而不是怎么做。

不管你打算怎么去描述你的规则，有一样事情必须总先考虑:显式定义。
记住，任何没被囊括在你规则的事情，都应该被视为异常，所以显式定义你的规则可以帮助你制定在不同的场景下，你的代码应该有怎样的行为，包括应该在什么时候抛出异常。


还要一点，要保持一致。
很多类和函数，名字和接口看上去都差不多，那不管他们在什么地方，他们的行为应该是类似的。
如果程序员在使用相类似的组件时，那么某个特定的功能，他们总会习惯于会有相类似的行为，他们最好就是想看到这些期望。
所以你在写代码的时候，最好就模仿Python或者Django里面的类型，这些类型都是被很多程序员觉得文档写得好，易于理解


社区
====
自从2005年向大众发行，Django在技术上和文化上都获得了巨大的成功。
Python积累了一大批粉丝，是在Python Web开发世界的爱好者和专业人士。
对于框架还有他的用户而言，这个社区是一项最伟大的财富，一些细节我们值得继续讨论


.. seealso::
  一个进化中的社区
  意识到Django社区像任意社会结构一样，一直在进化和改变，这非常重要。
  所以这章的信息，可能已经不能准确地反映此时现实的实践和期望。


尽管，这没有理由因此阻止你。
我不希望改变的一件事就是，社区乐意去拥抱新成员。
如果你愿意把自己放那，你总是可以接触到大量的人。

框架的管理
--------

对于Django的开发，其实Python也是一样，你需要知道的第一件事就是，即使框架的代码是每个人都可以看到和修改(毕竟他是开源的)，核心贡献的宏观管理是由一小部分人控制的。
有权限更像主代码仓库的人组成了这些"核心开发者"。

什么是核心?

因为Django是开源的，任何人都可以更改Django的代码并且发布这些修改过后的拷贝。
很多开发者已经在这么干，增加一些有意义的功能和增强功能，再把他们的成果分享给其他人。
先进的开发中可以对核心代码做一些非常重大的更改，而不会影响到那些没有用到这些功能的使用者。

此外，开发中被允许，被孤立，把他们的应用变得更加通用，然后把应用分发给其他人。
这些应用就会被越来越多的人用在他们的新项目里，作为默认选项，"装机必备吖"。


与此相反，Django核心只是简单的代码，在Django主网站分发给大家，例如一个官方的release，或者开发代码主分支。
所以当讨论甚至争论是否应该把一些东西加入核心，困境是应该把他加入官方的发布中，还是放到第三方，例如一个分支或者是发布的应用。


django.contrib包是一个有趣的灰色地带。
他被包含在Django主发行中，从而获得成为核心的资格，但是他们被设计成作为第三方应用来使用。
其目标是，当一个第三方的应用写得足够好，在社区里获得了足够的吸引力而且承诺会继续支持更新，最终他就会被加入到核心。
事实上，他们经常会走向另一个方向，把django.contrib包从核心删除，而作为第三方应用


这种结果有助于保证，那些对框架最有经验的，他的历史可查找的，经常调整的，在他们别提交到源码库之前的补丁。
他们也经常对框架最近的开发问题进行讨论，还有讨论一些需要完成的重大修整，需要完成的一些重大的改进，等等。


一些人仍然在管理链的最顶层。
这个职位叫 仁慈的独裁者(Benevolent Dictator for Life)，缩写为BDFL，用来指代，那些对所有决定有无限的权限，他需要打破平局，推翻大多数人的决定。
幸运的是，他们真的是仁慈的独裁者，不会轻易地做决定。


事实上，BDFL这个主意，非常的幽默诙谐。
虽然他们拥有无限的权力，但这个权力很罕见会被使用，因为他们会听从群众的意见。
当他们需要干涉并仲裁一个决定的时候，他们裁定的依据是这么多年来，知道什么是对框架和听众最好，的经验。
事实上，他们经常会向群体详细描述他们的主意，如果有合理的争议，甚至可能屈服于群体。


这种BDFL的方式，可能对于那些公司背景出来的读者来说比较陌生，公司环境下，设计决定通常是由委员会决定的，重大的规则和改变需要走一趟详尽的官僚流程。
反而，在不同的领域里，一小群的专家经常是不受监管的，他们在表现独立，开发出高质量的代码上非常厉害。
这种简单的结构会使流程在必要的时候走得非常快，更重要的是，在框架内帮助维持更高的一致性。


在Python领域，Guido van Rossum，Python的创始人，就在BDFL这个位置上。
至于Django，这个位置上有两个人，头衔是co-BDFL，Adrian Holovaty，框架的联合创始人，还有Jacob Kaplan-Moss，目前Django的开发者带头人。
贯彻这一章的原则和哲学，其实是BDFL们反映的意见和理想，他们说要写的。

新闻和资源
---------
在一个像Django那样有激情和活力的社区，很重要的是，看看别人都在干嘛，对于一些普遍问题他们是怎么解决的，新应用出来了，还要很多其他事情
考虑到社区的大小和多样性，跟上他，似乎是一个使人畏缩的任务，但他其实非常简单。

第一件事就是，留意Django的博客，这是官方新闻放出的地方，包含了很多关于框架本身的新闻和更新，框架的开发还有他被使用到什么重要的地方。
例如，Django博客会发布新release，即将来临的开发计划，项目网站的更新。

可能更重要的是Django社区的新闻聚合，这里收集了全世界开发者的文章，把他们都在一个地方展示。
这里信息的多样性更加丰富多彩，因为他是由社区成员生产的，使他成为了一项非常有价值的资源。
内容可能会包含新的和更新的应用，解决大家问题的tips还有技巧，使用到Django的新网站。



可复用的应用
----------

Django其中一个最有价值的方面就是，他的开发专注于"应用"，而不是自己在那空想，是基于应用的需求来开发框架的。
比起从头创建每一个网站，开发者更应该为一些明确的用途来开发应用模块，然后把这些模块组合在一起创建网站。
这种哲学激励很多社区成员把他们写的应用作为开源向大众发布，使得其他人可以从他们的功能里获益。
开发者是很自由地放置他们的应用，想放哪放哪，但是很多人都选择GitHub，因为Github功能丰富，在开发者社区很活跃，就是很多开发者用他。
事实上，Django代码就是放那的。
GitHub集成了他的问题跟踪系统，使得很方便在一个地方维护所有东西。
很多应用在寄放在那，所以很值得你话几分钟去找找有没有人已经写出了你所需要的东西。
你也可以在Django Packages寻找和比较第三方应用。

毕竟，开源软件有的一个主要目标是:一个更大的社区比一个只有专注开发者的小团体，可以产生更好、更干净、功能更强大的代码。
Django社区展示了这个行为并且鼓励其他人利用这个优势。

获取帮助
-------

尽管所有的知识在这本书内，还有其他书内，也不能假装能超前记录任何的情景下的问题。
再说，文档不是总能容易找到或者看得懂。
在这些情景下，你会发现你自己需要把你的场景告诉给其他活生生的人，那些人有现实世界的经验，期望他们可以定位到问题并给出解决方案。

第一件事你需要知道的是，这并不是一个问题。
任何人都可能嵌入一个不在意料之中的场景，甚至我们当中最聪明最好的人，都有可能被简单的语法错误所迷惑。
如果这发生了在你身上，你要知道其实Django社区是很好人的，当你需要的时候，你可以请求别人的帮助而不用害羞。

阅读文档
^^^^^^^
尝试解决任何问题的第一步，都应该是先阅读官方文档。
官方文档非常彻底，定期更新，新功能的添加，现有行为的改变，都会在上面的了。
当运行程序出现错误，文档可以帮助你确定，你有没有按照Django期望的方法去做。


当你的代码跑起来符合文档的展示，那是时候去看看其他的公共问题。





检查你所使用的版本
^^^^^^^^^^^^^^^^
正如前面的提及到的，官方文档是跟上Django的主线开发的，所以肯定会可能出现文档的功能，跟你正在用的代码功能不一致。
如果你使用一个官方的版本，这更加不容易发生，但如果你是跟踪使用主干代码这依然会发生，这依赖于你多频繁更新你的本地拷贝。

当你追踪主干分支，有关向后不兼容的改变的文章，应该作为你必看的官方文档部分。
如果你更新了之后发生问题，确保你使用的功能，都没有在这次更新发生过改变。



Q&A
^^^^
在几年时间回答问题中，Django社区在日常听到了各种各样的问题。
为了更方便地回答这些问题，诞生了两篇文章。
尽管官方FAQ包含了很多问题，但仍然有几个公共的问题列表在那。

IRC频道有他自己的FAQ和问题回答集合。

邮件列表
^^^^^^^
其中一个非常方便问你问题的地方就是django-user邮件列表
因为他是通过标准邮件来运行的，所以他会发给每一个人，不需要其他特定的软件。
简单加入列表后，你可以发表你的问题，上千的其他人就会看到。
虽然没有任何保证，但大部分的问题都会得到快速的回答。

邮件列表的一个关键优势就是，他所有的对话都是存档的，以便以后参考。
作为FAQ的补充，当你尝试跟踪一个可能是其他人以前遇到过的问题时，django-user邮件列表是一个无价的资源。
确保你在问你问题之前已经搜索过存档，因为很有可能其他人之前也遇到过。



IRC聊天频道
^^^^^^^^^^

如果你需要更快的回答，最好的选择就是Django的IRC频道，那里有很多知识渊博的Django社区成员，可以直接跟你对话。
这是一个非常有用的环境，但你应该准备好这个问题的有关细节。
这可能包含所有的出错回朔栈，模型的代码片段，师徒，还有其他可能跟问题有关的代码。

代码经常会使用一个在线的工具pastebin来分享，这个地方可以临时放置代码，以供其他人查看。
代码可以短时间内贴到一个公共的网站，允许分享给其他人。
GitHub为了这个目的提供了一个工具，叫gitst，他是一个可以跟IRC或者其他地方的用户分享代码的工具。


接下来干嘛?
---------

当然，学习有关哲学和社区的知识，并不能教到你写任何代码。
他教你怎么使用好工具，但这些工具还没有实际地用得上。
下一章概况了很多平时很少用上的有用工具，有Python自己提供的，再后面的所有章节，我们来探索很多Django自己的工具集。










