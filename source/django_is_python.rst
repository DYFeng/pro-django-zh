Django源自Python
****************

（译者注：这个标题的翻译我纠结了很久。其含义是说，Django的构架哲学继承于Python，使用的时候不应该脱离Python的使用哲学）

Django跟其他的框架一样，都是建立在一门特定的语言上（Django建立在Python上）
许多人第一次接触Django的时候，同时也是第一次接触Python。
Python口语化的语法结合Django简洁的用法，令到很多人以为Django使用了某些元编程，然而事实并不是这样。

如果想知道Django是怎么运作的，那你得首先意识到Django本质上也是Python，正如你所写的其他Python程序一样。
Python能实现的，Django一样能够实现，在Django身上有着有无限的可能性。

这也意味着Django程序不仅仅能调用到Python标准库，还能调用到海量的第三方库和工具。
有一些库提供了专门的接口给Django调用（译者注：例如分布式计算库celery有对于的Django库django-celery），在这些场景下，现有的代码和文档可以让你快速搭建运行应用。

在本书稍后，会介绍一些额外的工具，还有一些把他们整合到Django的技巧。
除了本书所提及到的，你也可以自己找一些Python工具来支撑你的业务，使用本书提及的技巧来把他们整合到你的程序里面。

虽然讲解Python知识已经超出了本书的范围，但Django使用了其中的一些高级功能。
在这章，我将会讨论一些高级的功能，就是这些功能令到大部分人都觉得Python方便易用。

Python是如何创建类的？
===================

Django依赖了Python很多先进技术，其中很多技术点都跟Python怎么构建他的类息息相关。
这个是Django的核心，已经被很多开发者习以为常，它是我们这章讨论的基石。

当Python解析器遇到类的定义，他会像读取其他代码一样读取其内容。
Python为这个类创建一个命名空间（namespace）并且在里面运行其代码，把变量分配到这个命名空间内。
类的定义（definition）一般包含变量，方法和其他的类，这些东西基本上都分配到了类的命名空间内。
事实上，这里几乎允许所有的有效代码（语法错误的除外），包括打印到终端的输出，写日志文件，甚至触发界面交互。

一旦这些内容都执行结束，Python的类对象（class object）就会分配到他原来所在的命名空间里（一般来说是这个模块的全局命名空间），他会被继续传递或者被实例化成对象。

>>> class NormalClass:
...     print('Loading NormalClass')
...     spam = 'eggs'
...     print('Done loading')
...
Loading NormalClass
Done loading
>>> NormalClass
<class __main__.NormalClass>
>>> NormalClass.spam
'eggs'

正如你所见，类里面的代码会被执行。
当类准备完毕，类里面的变量会被赋值成类属性。

用代码动态创建类
--------------

在此之前，我们讲述的都是使用代码定义（source-declared）类，但Python能用更加有趣的方法来实现。
内部实现如下，有关这个类的定义信息会被送到一个内置类 *type* 里面，他会根据这些信息创建一个Python类。
其实当解析器完成对每个类的内容解析后，会自动完成以上步骤。

type构造器需要三个参数，就是这三个参数构成了一个类的定义。

- name -- 类的名字，字符串
- bases -- 多个父类组成的一个元组，可能为空
- attrs -- 一个字典，承载了类命名空间里面的所有数据

.. seealso::

    兼容性：Python2的新式类

    这章我们谈的其实是，自Python2.2引进的新式Python类（new-style class）。
    旧式类（old-style class）已经被Python3完全移除，但如果你还在使用Python2，你需要强制使用新式类。
    使用新式类很简单，只要保证你的类继承内置类型 *object* 即可。

    所有的Django类都继承自 *object*，所以你可以用上新式类的所有特性而不用做额外的工作。
    但是你依然需要清楚了解新式类与旧式类的区别。

就像普通的Python对象那样，*type* 可以在任何时间任何代码位置创建对象。
这意味这你的代码可以基于需要，在运行时创建一个新的类。
下面的代码演示了在运行时声明一个类，这个类的功能跟我们上一小节演示的一模一样。

>>> DynamicClass = type('DynamicClass', (), {'spam': 'eggs'})
>>> DynamicClass
<class '__main__.DynamicClass'>
>>> DynamicClass.spam
'eggs'

.. seealso::

    关于type()的注意事项

    手动使用type()创建类，很容易会出现重名的情况。
    即使类所在的模块位置，可以通过设置第三个参数attrs['__module__']来实现。
    虽然这些特性非常有用，本书后面章节将会展示，他是怎么令到内省（introspection）出现问题。

    你完全可以在同一个模块创建两个相同名字的类，但你的代码根本不能区分这两个相同名字的类（译者注：就像同一个变量被多次赋值那样）。
    在一些场景下这可能不是问题，但值得你留意。

元类改变一切
----------

type其实是一种元类（metaclass）-- 一个可以创建其他类的类（好拗口吖），我们所进行的这种编程叫元编程。
本质上，元编程比较倾向于在运行时创建或者更改代码，而不是在编码时。
Python允许你给类定义一个不同的元类，来自定义这个创建过程。

单独定义一个元类，在类定义时把这个元类作为 *metaclass* 选项，这个元类用于创建类，而不使用内置 *type*对象。
这允许你的代码读取、修改、甚至完全替换这个类，来进一步自定义其功能。
元类从技术上讲，可以是任意一个有效的Python调用（Python callable），但大多数元类都是继承于 *type*。
元类接收一个新类作为他第一个参数，并且提供对这个类对象定义明细的访问。

下面的例子可以帮助你理解元类参数是怎么参与类定义的。（译者注：下面代码只是Python3可用）

>>> class MetaClass(type):
...     def __init__(cls, name, bases, attrs):
...         print('Defining %s' % cls)
...         print('Name: %s' % name)
...         print('Bases: %s' % (bases,))
...         print('Attributes:')
...         for (name, value) in attrs.items():
...             print('%s: %r' % (name, value))
...
>>> class RealClass(object,metaclass=MetaClass):
...     spam = 'eggs'
...
Defining <class '__main__.RealClass'>
Name: RealClass
Bases: (<class 'object'>,)
Attributes:
__module__: '__main__'
__qualname__: 'RealClass'
spam: 'eggs'

注意这个类并没有实例化。一个简单的例子怎么在类的创建过程中触发元类的执行。
注意 __module__ 在属性列表里。
这个属性是所有Python类的标准组成部分之一。


这个例子使用了__ini__ 方法在类创建时执行一些特殊操作，我们也可以使用另外一个强大的方法 __new__ 来实现
在讲述这章的后面，Django很多类会使用 __new__ 来做配置。

兼容性:在Python2中使用元类

Python3可以在类定义的时候传递参数，就像这里展示的的metaclass选项一样。
在Python2中，元类会被赋值到一个类变量__metaclass__里。
其实他们的效果一样，唯一的不同只是语法的改变。


在一个基类上使用元类
----------------

元类非常得有用，但metaclass选项是一个实现细节，不应该出现在我们在定义类的过程中。
另一个问题是，在使用元类的过程中，这些类并没有从一个特定的类继承。
这意味着额外的方法和属性，必须由元类创建的时候提供。


我们只需要一点技巧，一个特定的Python类可以使用元类来解决以上的问题。
当一个子类继承于父类的时候，metaclass选项自动会继承下去。
这是一个简单有效的方法，为任意的类提供元类处理，而不需要每个类单独定义metaclass选项。
接着我们上一章的例子，来看看我们继承RealClass会发生什么事情。

下面Python3可用

>>> class SubClass(RealClass): # 注意这里没有metaclass
...     pass
...
Defining <class '__main__.SubClass'>
Name: SubClass
Bases: (<class '__main__.RealClass'>,)
Attributes:
__module__: '__main__'
__qualname__: 'SubClass'

元类在幕后正常工作，子类完全不用担心。
只需要定义一个基类，他就能继承所有的特性。
Django使用这个行为去实现一个使用非常广泛的特性，将会在下一章讲述。

Declarative语法
--------------

Django的大部分工具都使用了一个叫"declarative 语法"的特性，令其读写和理解变得简单。
这个语法设计的目的就是最小化呆板的重复代码，令代码更加优雅可读。
下面以一个Django模型来举例。

.. code-block:: python

    class Contact(models.Model):
        """
        Contact information provided when sending messages to the owner of the site。
        """
        name = models.CharField(max_length=255)
        email = models.EmailField()



这种 declarative 语法已经成为了Django代码的标志性特性，很多第三方的应用都在学Django，提供类似的语法。
这有助于开发者编写易懂，紧凑的代码。
一旦你懂得怎么使用 declarative 语法来创建类，你可以很方便地调用Django的诸多特性，包括第三方社区提供的。

仔细看 declarative 语法你就会发现为Django创建一个适配Django模式的，全新的框架是多么的容易
在你的代码里使用 declarative 语法，可以令你和你的同事更加容易适配代码，提高生产效率。
归根到底，提高开发者效率是Django和Python本身的第一要任。


下面几小节讲述 declarative 语法，例子是展示 Django 的 ORM object-relational mapper ，这个会在第三章详细讲述/


集中式控制
--------

一般而言，一个包会提供一个单独的模块， 应用可以访问所有需要的工具。
这个模块会引入其他地方的独立类和函数到其命名空间下，所以他们还能用原来的命名空间，但他们会被收集到一个集中的地方。

.. code-block:: python

    from django.db import models

引入后，这个模块提供了至少一个父类。
额外的类被作为新子类的属性。


基类
----

每个特性至少属于一个基类。
甚至因为基于框架的需要，为了使语法正确，我们需要至少一个基类。
没有基类，你只好叫你的使用者给每个类显式加上一个元类，但这是一个实现的细节，使用者不应该必需要知道。

.. code-block:: python

    class Contact(models.Model):



为了可以检查这些自定义的属性，基类提供了一系列方法和属性让子类继承。
就像其他类一样，他可以根据框架的需要，提供简单或者复杂的功能。


属性类
-----

属性类提供了一系列的类供给基类使用，这些属性类通常可以通过参数来自定义其行为

.. code-block:: python

    class Contact(models.Model):
        name = models.CharField(max_length=255)
        email = models.EmailField()



这些属性类为框架带来了多种多样的功能，有一些甚至与标准属性有很大的区别。
他们会结合元类来提供一些额外的，在幕后静静工作的功能，而不只是属性赋值这么简单。
元类往往会读取这些属性类的参数来创建这些额外功能。


例如，Django的Model使用字段名称和字段属性来描述一个数据库实体表，这个数据库实体表还能根据类自动创建。
你可以通过字段名来访问数据表的列，字段还能把原生Python数据类型转换成相对应的数据库值。
更多关于Django这么处理模型类和字段的信息，请看下一章。

类属性排序

人们在使用declarative语法的时候，有可能会有困惑，Python字典是无序的，他不能记录值被赋值的顺序。
一般而言，这不是个问题。但当分析一个命名空间字段时，有可能需要知道定义键值时的顺序。
如果一个框架需要迭代遍历他的这些特殊属性，或者展示给终端用户/程序员，以定义顺序一致的访问是有用的。
这给了程序员一个控制属性顺序的机会，而不是任由程序语言来控制属性的顺序。


一个简单的解决方案是，用一个属性来记录他们实例化的顺序.元类可以根据这个属性来排序。
当属性类都基层至一个特定的基类时，我们可以使用这个方法来记录属性类被实例化了多少次，实例化的属性类把这个次数给记录下

.. code-block:: python

    class BaseAttribute(object):
        creation_counter = 1
        def __init__(self):
            self.creation_counter = BaseAttribute.creation_counter
            BaseAttribute.creation_counter += 1




实例化的对象跟类不在同一个命名空间里，所以所有这个类的实例化对象都会有一个creation_counter属性，实例化的时候可以作为排序的依据。
这个不是唯一的方案，但Django就是是这个方法来排序模型和表单字段的。


类的定义
-----
模块里面有了这些类，创建一个应用类就像定义一个子类和属性一样简单。

他们甚至会有一些保留名称，如果你定义了一个属性名称且好是这些保留名称，就会引起冲突，但是这种问题其实是比较罕见的。
当开发一个新框架使用到这种语法的时候，不鼓励使用保留名称。
通用法则是允许开发者拥有最大的灵活性，框架不应该干预。

.. code-block:: python

    from django.db import models

    class Contact(models.Model):
        """
        Contact information provided when sending messages to the owner of the site。
        """
        name = models.CharField(max_length=255)
        email = models.EmailField()



上面这小段代码已经足够让框架像新类灌输一大堆额外的功能，而不需要程序员手工来处理这个过程。
还要注意，所有的属性是怎么由相同的基础模块提供并实例化分配给模型。

一个类的定义，从来都不会受限于框架提供的这些功能。
只要你写的是合法Python代码，你的类会包含大量的方法和其他属性，还混杂上框架提供的功能。


鸭子协定
========
你可能已经听过这个古老的格言，"如果它走起路来像一只鸭子，叫起来像一只鸭子，那他就是一只鸭子"。
莎士比亚在写罗密欧与朱丽叶的时候，把这演绎得更加浪漫，"名称有什么关系？玫瑰不叫玫瑰，依然芳香如故。"。
这个我们已举了不少例子了，目的就是要告诉大家，给一个对象命名并不能改变这个对象本身的行为，
主要概念是，不管又多少标签，你都可以合理的认为一样东西是什么，可以依据他的行为表现为怎样。

在Python里，或者其他的一些语言，这个概念被扩展为，跟对象类型有关。
比起依赖某些基类或者接口来定义一个对象可以咗什么，他只需要实现期望行为所需要的属性和方法
在Python里一个广为人知的例子就是，类文件对象(file-like object)，只要任意一个对象至少实现了几个必要的方法，他就可以被视为Python文件对象。
使用这个方法，很多库可能返回他们自己的对象，那些对象能够传递到那些期待文件对象的函数，但同时这些对象保留了特殊的属性，例如是否只读，被压缩，被加密，从某个互联网连接的源拉下来的，还有很多其他的可能。


还有，像其他语言的接口，Python对象在同一时间可以拥有不止一种鸭子类型。
这不是很常见，举个例子，在某些时候，需要一个对象表现为一个字典，在其他时候需要表现为一个列表。
Django的HttpResponse对象就继承了这些行为，与此同时还模仿了open file object的行为。


在Django里，很多功能工具集都使用了鸭子类型，而不定义一个特殊的基类。
反而，每个功能都定义了排序的协议，一系列方法和属性，这些都是一个对象为了正常运作必须提供的。
这些协议都可以在Django官方文档里面找到，而去这文档会覆盖更多的协议。
你也会看到一些特殊属性也是由这项技术提供的。

下面的章节会描述一小部分大家用得比较多的Python协议，这些协议贯穿了Django。也贯穿了很多大型的Pytho库(就是说很多大型的Python库也是主要用着这些协议)。


Callable
--------
Pytho允许代码从很多源那里开始执行，被设计成callable的任何东西，行为就像一个函数那样可以被执行。
所有的函数，类，方法，都是自动可以callable的，任何对象类的实例，都可以通过提供一个方法被设计成callable。

__call__(self[，...])
当一个实例化的对象像函数那样被调用，这个方法就会被执行。
他工作起来就像其他的成员函数那样，唯一的不同是他被调用所表现的行为。

>>> class Multiplier(object):
...     def __init__(self, factor):
...         self.factor = factor
...     def __call__(self, value):
...         return value * self.factor
...
>>> times2 = Multiplier(2)
>>> times2(5)
10
>>> times2(10)
20
>>> times3 = Multiplier(3)
>>> times3(10)
30

Python也提供了一个内置函数来帮助判断是否一个callable对象。
callable()函数接受单一个参数，返回True或者False，来判断一个对象是否可以像一个函数那样被调用。

>>> class Basic(object):
...     pass
...
>>> class Callable(object):
...     def __call__(self):
...         return "Executed!"
...
>>> b = Basic()
>>> callable(b)
False
>>> c = Callable()
>>> callable(c)
True


字典
---
一个字典用单
一个字典用单一个对象来维护一系列键值对。
大部分的编程语言都有类似形式的字典。其他语言会叫他 哈希 maps associtive arrays。
只需要通过指定键就可以访问值，Python的字典提供来很多方法精确操控底层mapping。
一个对象需要提供其他方法，来让他的行为更像一个字典，Python库参考又详细文档。


__contains__(self,key)
---------------------
当使用in操作符的时候，会被调用，如果指定的key在底层mapping里，他返回True，否则返回False。
这个函数永远不应该返回一个异常。

__getitem__(self,key)
----------------------
如果这个key存在语底层mapping，则返回跟指定key关联的值，否则应该抛出一个KeyError异常。

__setitem__(self,key,value)
------------------------------
他会根据指定key来储存这个value，如果已经有这个key的mapping，他会把value覆盖旧值。

>>> class CaseInsensitiveDict(dict):
...     def __init__(self, **kwargs):
...         for key, value in kwargs.items():
...             self[key.lower()] = value
...     def __contains__(self, key):
...         return super(CaseInsensitiveDict, self).__contains__(key.lower())
...     def __getitem__(self, key):
...         return super(CaseInsensitiveDict, self).__getitem__(key.lower())
...     def __setitem__(self, key, value):
...         super(CaseInsensitiveDict, self).__setitem__(key.lower(), value)
...
>>> d = CaseInsensitiveDict(SpAm='eggs')
>>> 'spam' in d
True
>>> d['SPAM']
'eggs'
>>> d['sPaM'] = 'burger'
>>> d['SpaM']
'burger'

字典也是被期望可以迭代的，使用键的列表就可以循环字典的内容。
查看下面 Iterables 章节来获取更多内容。

文件
----
像之前描述的那样，文件是一种广泛用来获取信息的方法，Python库提供来类文件对象，被用于其他文件相关的函数。
一个类文件对象不需要提供所有下面的方法，就需要提供那些函数需要的。
有了文件协议，对象可以方便实现读，写，或者两者皆有。
不是所有的方法都写在了下面，只有一些使用率最高的。
你可以在Python标准库文档里找到一份完整的文件方法列表，确保你自己去查看他来获取更多细节。


read(self,[size])
-----------------
这个函数从对象那获取数据，或者是他的信息源。
可选参数size代表了需要获取多少比特数据。
没有这个参数，这个应该应该返回尽可能多的数据(经常是整个文件，如果可能的话，可能是一个网络接口所有可用的比特)。


write(self,str)
---------------
这个函数把特定的str写入对象，或者他的信息源。


close(self)
-----------
这个会关闭那些不再访问的文件。
这用来释放出那些已经分配的内存资源，把文件内容提交到硬盘，或者只是为了简单地完成协议。
甚至如果这个方法没有提供特定到功能，他应该避免任何不必要到错误。

一个非常松的协议
类文件对象有很多变种，因为这个协议是其中一个Python定义的最宽松的协议。
有一小部分功能，从缓冲区输出，到允许随机访问数据，在一些场景并不是那么适用，所以在这些场景下设计的对象，会选择性地不实现某些对应到方法。
例如，将会在第七章描述到到，Django的HttpResponse对象，只允许按顺序写，所以他并不实现read()，seek()，tell()，在一些操作文件的库使用，会出现错误。

一个公共实践就是，在一些场景，把一些不会用到的方法不实现，使到访问这些方法到时候会抛出AttributeError异常。
在一些其他情况，一个编程者可能决定去实现他们， 但简单抛出一个NotImplementedError异常去显示一个更加有描述性的信息。
你必须永远记录下你的对象实现了多少协议在文档里，以致用户不会感觉意外，什么时候感到意外?当尝试把这些对象当作标准文件使用的时候发生错误，特别是在第三方库。

可迭代的
假如一个对象作为参数传进内置函数iter()而且返回一个迭代器，那这个对象就应该被认为是一个可迭代的。
iter()在一个for循环里面经常会被隐式调用。
所有的列表 元组 字典 都是可迭代的，还有所有的新式类定义了以下方法后，也可以变成可迭代的。

__iter__(self)
这个方法会在iter()里面隐式调用，这个方法负责返回一个迭代器，令到Python可以使用他从对象里获取元素。
迭代器经常把这个方法定义成一个generator函数，来实现这个迭代器，详细的会在下面"Generators"章节讲述。

>>>

迭代器
-------
当iter()被一个对象调用，他期望他会返回一个迭代器，令到他可以使用这个迭代器从对象获取序列一个个元素。
迭代器是一种单向遍历可用元素的简单方法，每次返回一个值，直到没有为止。
对于一个大的集合而言，一个个元素这样子来获取，要比一次性把元素都收集到一个列表里更加有效率。

next(self)
---------
一个迭代器唯一需要用到的方法，他会返回唯一的一个元素。
怎样返回元素，依赖于这个迭代器是设计用来干什么的，当他必须返回一个且只有一个元素。
当那个元素已经被所谓的迭代器处理后，当next()再次被调用时，会返回下一个元素。


一旦再没有元素可以被返回，next()还负责告诉Python停止使用迭代器，并在循环后继续运行。
当完成的时候，会抛出一个StopIteration的异常。
Python会不断调用next()直到一个异常被抛出，导致一个无限的循环。

要么应该使用StopIteration来优雅停止循环，要么使用另外一个异常，这会引出一个更加严肃的问题。

class

注意那个迭代器没有为来正常使用，而显式需要定义__iter__()，当包含了那个方法，允许循环能够直接使用迭代器。


兼容性:在Python2中使用迭代器

Python3里面对于迭代器只有一个非常小的改变。
在这里的__next__()方法以前是叫做next()。
注意这个消失的下划线。
这个改变是为了遵从Python命名魔术方法的命名习惯，魔术方法是在方法的名字前后添加双下划线。

如果你需要同时支持Python2和3，解决方法也相当简单。
在你像我们Fibonacci例子那样定义__next__()之后，你可以把__next__()方法直接赋值给一个类方法:next=__next__。
这个可以放在类定义的任何位置，当他最好被刚好放在__next__方法的后面，这可以令代码保持紧凑。


生成器(Generators)
--------------------

正如上面斐波纳契的例子，生成器是生成简单迭代器的快捷方式，而不用定义另一个类。
Python判断一个函数是否生成器的标准四，这个函数里面有没有yield语句，这会令到这个函数的行为与其他函数有所不同。

当调用一个生成器函数，Python不会立马执行他的代码。
这时，他会返回一个迭代器，这个迭代器的next()方法会调用函数体代码，一直运行到达第一个yield语句的位置。
yield语句的返回值，会被next()方法返回，这时候所谓生成器的代码就能拿着这个值来工作。


下一次迭代器调用next()函数，Python继续在生成器函数上一次离开的地方执行，他的所有变量都保持原来不变。
Python遇到yield语句会不断重复这个过程，就像使用一个循环来yield值。
当这个函数，不再yield一个值，完结了，这个迭代器会自动抛出一个StopIteration来告诉循环是时候结束来，接下来的代码会继续运行。


序列
------
迭代器会告诉你，从这个对象每次可以获取到一个值，我们都知道这些值由单一的一个对象收集和发展的。
这就叫一个序列。
广为人知的序列类型是列表和元组。
作为可迭代的东西，序列也使用__iter__()方法来一个个返回他们的值，但自从这些值是可被预见的，一些额外的功能可用。


__len__(self)
当所有值都可用的时候，序列会有一个确定的长度，你可以用内置函数len()来看到这个长度。
内部实现呢，len()会检查对象是否有__len__()方法，有的话就使用他来获取序列的长度。
为了完成这，__len__()应该返回一个整形，就是这个序列包含元素的数量。

技术上，__len__()不需要预先知道里面所有的元素，只需要知道里面有多少个。
因为不可能只有部分元素，一个元素要么存在要么不存在，__len__()应该返回一个整数。
如果不是，len()也会强制他是一个整数。
>>>

__getitem__(self)和 __setitem(self,value)
在一个序列里面的所有的值都已经被排序好，所以是可以通过他们在序列里的索引来访问某个独立的值。
访问的语法跟字典键完全一致，Python使用跟之前字典描述相同的两个方法。
这可以允许一个序列自定义他每个值被怎么访问,或者限制设置新值到序列,使他只读。


变参函数
======

为了标准声明和调用,Python提供了选项,允许你使用有趣到方法来调用函数。
Django使用这些技术来帮助他高效重用代码。
你也可以在你到应用里使用相同的技术,他们是标准Python的一部分。

额外参数
-------

在运行的时候,不是总能知道有什么参数提供了给函数。
Django里就经常出现这种情况,类方法在源代码里被定义,甚至在子类自己被适当定制化。看不懂这句话
另外一个常见的场景是,一个函数可以在非常多的对象上起作用。
在那种情况下,函数自己调用自己,会变成一系列API,供给其他应用使用。


为了这些情况,Python提供了两个特殊的方式来定义函数参数,允许函数接受额外参数,而不受显式定义的参数的限制。
这些"额外"的参数就是下面解释的。


注意args和kwargs的名字仅仅是Python的命名惯例,你也可以用其他的名字。
作为任意函数的参数,你可能会根据自己的喜好来命名他们,但跟标准Python惯例保持一致,可以令到你的代码对于其他的编程者来说可读性更加高。


位置参数
-------
在参数名字前使用一个星号,来允许函数接受任意个位置参数。

>>>

Python把参数放进一个元组里,你可以使用变量args来访问。
如果你上面显式定义来,但是又没有提供位置参数,这个参数就赋值成一个空元组。

关键词参数
---------
Python在参数名字前使用两个星号,来支持任意关键词参数
>>>

值得留意的是,kwargs是一个普通的Python字典,包含来参数的名字和值。
如果没有额外的关键词参数提供,kwargs是一个空字典。


混合参数类型
-----------
任意的位置参数和关键词参数可能会被用在其他标准参数定义里。
把他们混在一起使用需要小心,因为他们的顺序对Python来说很重要。
参数可以分成四类,不是所有的分类都是必须的,他们必须按照以下的顺序定义,跳过任何项是无用的。

- 必须参数
- 选填参数
- 额外的位置参数
- 额外的关键词参数

之所以需要这个顺序是因为 *args 和 **kwargs 只能在这些值没有被放置在其他参数的情况下,获取得了。
没有这个顺序,当你用位置参数调用一个函数的时候,Python就无法判断哪些值是已经定义好的参数,哪些是应该被看作额外的位置参数。


还有需要注意的是,函数可以接受任意数量的必要和选填参数,额外参数的其中一个。

传递参数集合
----------
为了使函数可以接收到任何参数集合,Python代码可能使用任意个数到参数来调用函数,使用之前说的星号语法。
参数使用这种方法来传递,Python会把他展开成一个普通的列表,


任何的Python调用都可能使用这种方式来调用,他有可能跟标准参数结合,使用相同的优先级规则。
>>>
就像这个例子的最后一行描述的那样,如果你要显式传递任何关键词参数进去的同时还传进一个元组作为额外的位置参数,你要特别小心。
因为Python会使用优先级规则来展开额外的参数,位置参数会优先解析。
在这个例子里面,最后两个两个调用是完全一样的,Python分不清楚那个值是赋值给a的。

装饰器
------

另外一种常见改变函数行为的方法是,把他用另外一个函数来装饰。
这也经常被叫做"wrapping"包装函数,装饰器是设计为了,在原函数调用之前或者之后,执行一些额外代码。


装饰器背后的一个关键点是,他接收一个可执行,然后返回一个新的可执行。
被装饰器返回的函数,稍后在装饰器被调用时会被执行。
必须小心留意保证原来的函数在这个过程中没有被遗弃,因为在不重新加载模块的情况下,你就无法找回他。

装饰器在很多情况下会被应用,要么你直接定义一个函数,要么这个函数在其他地方定义。
自从Python2.4,装饰器在新定义的函数可以使用一种特殊的语法。
在过去的Python版本,需要一个有点不一样的语法,当相同的代码可以用在两种情况下,唯一的不同是,装饰器应用在函数上时,使用的语法不一样。

>>>


旧的语法是另外一种装饰函数的技术,当@语法不可用的时候,这种技术就能派上用场。
考虑到一个函数会在其他到地方被定义,但还是能够被装饰到。
像这样到一个函数,可以被传递到一个装饰器里,返回一个一切都被包装好到新函数。
使用这项技术,任何可调用到,无论他来自哪,他用来干啥,都可以被任何装饰器包装。


使用额外参数包装
------------
有时候,装饰器需要一些额外到信息来决定,应该对收到到这个函数做些什么。
使用老装饰器语法,或者当装饰任意函数到时候,这项任务非常容易实施。
只需要定义装饰器接受额外参数获取必要信息,在函数被包装到时候,提供这些必要信息。

>>>

然而,Python2.4到装饰器语法使到这件事复杂了。
当使用新语法到时候,装饰器永远只接收一个且只有一个参数:需要被包装的函数。
有其他的方式来让装饰器获取到额外到参数,当我们先讨论一下什么是partials

偏应用函数
--------
典型地,当函数在被执行的时候,会带上所有必须的参数被调用。
有时候,参数已经预先知道,远在函数被调用之前。
在这些情况下,函数可以先应用一个或者几个他的参数,使得在后面可以应用更少的参数。


为了这个目的,Python2.5在他的functools模块包含了partial对象。
他接受一个可执行,还有任意个数的额外参数,再返回一个新的可执行,看上去就像原来的一样,唯一的不同是,在后面的使用中,不需要指定这些已经预加载的参数。

>>>

Python2.5后面的版本,Django提供了他自己对partial的实现,叫加里函数,位于django.utils.functional。
这个函数可以在Python2.3或者更高版本运行。


回到装饰器问题
------------
正如之前描述的那样,装饰器使用Python2.4的语法,会导致一个问题,如果他们要接收额外的参数,当语法只是提供了唯一一个参数,就是被包装的函数本身。
使用偏应用技术,就可以在装饰器上预加载参数。
更早描述这个装饰器,下面的例子使用了curry(在第九章描述的),在使用更新的Python2.4语法时,提供参数给装饰器。

>>>

这仍然不是很方便,因为函数每次都需要通过curry来装饰另外一个函数。
一个更好的方法是,在装饰器内部来直接提供这个功能。
这就需要装饰器里写一些额外的代码,但可以令到他更容易使用。

这个技巧就是在另一个函数里面定义这个装饰器,这个函数能够接受参数。
这个新的外层函数会返回装饰器,这个装饰器稍后会被当作标准的Python装饰器使用。
这个装饰器这次反过来会返回一个函数,在装饰过程完成后,会被下面的程序使用到。

这真的非常抽象,我们来看看下面的代码,跟之前的例子功能一样,但是没有依赖curry,使到他更加容易使用。

>>>

单参数被期望时，这种场景下，这种技术使用得最为合理。
如果装饰器应用时，没有带任何的参数，为了使到它工作正常，括号依然是需要的。

>>>

第二个例子失败了是因为我们一开始没有调用 decorate。
因此，所有调用test的子请求，发送他们的参数给decorator而不是test。
这是一个错误匹配，Python抛出一个错误。
这种场景比较难调试，因为精确的异常抛出，这个异常依赖于被包装的函数。


一个装饰器，有或者没有参数
======================






描述符
======

自省机制
=======


已应用技术点
==========

下一步
=====
































































