Django源自Python
****************

（译者注：这个标题的翻译我纠结了很久。其含义是说，Django的构架哲学继承于Python，使用的时候不应该脱离Python的使用哲学）

Django跟其他的框架一样，都是建立在一门特定的语言上（Django建立在Python上）
许多人第一次接触Django的时候，同时也是第一次接触Python。
Python口语化的语法结合Django简洁的用法，令到很多人以为Django使用了某些元编程，然而事实并不是这样。

如果想知道Django是怎么运作的，那你得首先意识到Django本质上也是Python，正如你所写的其他Python程序一样。
Python能实现的，Django一样能够实现，在Django身上有着有无限的可能性。

这也意味着Django程序不仅仅能调用到Python标准库，还能调用到海量的第三方库和工具。
有一些库提供了专门的接口给Django调用（译者注：例如分布式计算库celery有对于的Django库django-celery），在这些场景下，现有的代码和文档可以让你快速搭建运行应用。

在本书稍后，会介绍一些额外的工具，还有一些把他们整合到Django的技巧。
除了本书所提及到的，你也可以自己找一些Python工具来支撑你的业务，使用本书提及的技巧来把他们整合到你的程序里面。

虽然讲解Python知识已经超出了本书的范围，但Django使用了其中的一些高级功能。
在这章，我将会讨论一些高级的功能，就是这些功能令到大部分人都觉得Python方便易用。

Python是如何创建类的？
===================

Django依赖了Python很多先进技术，其中很多技术点都跟Python怎么构建他的类息息相关。
这个是Django的核心，已经被很多开发者习以为常，它是我们这章讨论的基石。

当Python解析器遇到类的定义，他会像读取其他代码一样读取其内容。
Python为这个类创建一个命名空间（namespace）并且在里面运行其代码，把变量分配到这个命名空间内。
类的定义（definition）一般包含变量，方法和其他的类，这些东西基本上都分配到了类的命名空间内。
事实上，这里几乎允许所有的有效代码（语法错误的除外），包括打印到终端的输出，写日志文件，甚至触发界面交互。

一旦这些内容都执行结束，Python的类对象（class object）就会分配到他原来所在的命名空间里（一般来说是这个模块的全局命名空间），他会被继续传递或者被实例化成对象。

>>> class NormalClass:
...     print('Loading NormalClass')
...     spam = 'eggs'
...     print('Done loading')
...
Loading NormalClass
Done loading
>>> NormalClass
<class __main__.NormalClass>
>>> NormalClass.spam
'eggs'

正如你所见，类里面的代码会被执行。
当类准备完毕，类里面的变量会被赋值成类属性。

用代码动态创建类
--------------

在此之前，我们讲述的都是使用代码定义（source-declared）类，但Python能用更加有趣的方法来实现。
内部实现如下，有关这个类的定义信息会被送到一个内置类 *type* 里面，他会根据这些信息创建一个Python类。
其实当解析器完成对每个类的内容解析后，会自动完成以上步骤。

type构造器需要三个参数，就是这三个参数构成了一个类的定义。

- name -- 类的名字，字符串
- bases -- 多个父类组成的一个元组，可能为空
- attrs -- 一个字典，承载了类命名空间里面的所有数据

.. seealso::

    兼容性：Python2的新式类

    这章我们谈的其实是，自Python2.2引进的新式Python类（new-style class）。
    旧式类（old-style class）已经被Python3完全移除，但如果你还在使用Python2，你需要强制使用新式类。
    使用新式类很简单，只要保证你的类继承内置类型 *object* 即可。

    所有的Django类都继承自 *object*，所以你可以用上新式类的所有特性而不用做额外的工作。
    但是你依然需要清楚了解新式类与旧式类的区别。

就像普通的Python对象那样，*type* 可以在任何时间任何代码位置创建对象。
这意味这你的代码可以基于需要，在运行时创建一个新的类。
下面的代码演示了在运行时声明一个类，这个类的功能跟我们上一小节演示的一模一样。

>>> DynamicClass = type('DynamicClass', (), {'spam': 'eggs'})
>>> DynamicClass
<class '__main__.DynamicClass'>
>>> DynamicClass.spam
'eggs'

.. seealso::

    关于type()的注意事项

    手动使用type()创建类，很容易会出现重名的情况。
    即使类所在的模块位置，可以通过设置第三个参数attrs['__module__']来实现。
    虽然这些特性非常有用，本书后面章节将会展示，他是怎么令到内省（introspection）出现问题。

    你完全可以在同一个模块创建两个相同名字的类，但你的代码根本不能区分这两个相同名字的类（译者注：就像同一个变量被多次赋值那样）。
    在一些场景下这可能不是问题，但值得你留意。

元类改变一切
-----------

type其实是一种元类（metaclass）-- 一个可以创建其他类的类（好拗口吖），我们所进行的这种编程叫元编程。
本质上，元编程比较倾向于在运行时创建或者更改代码，而不是在编码时。
Python允许你给类定义一个不同的元类，来自定义这个创建过程。

单独定义一个元类，在类定义时把这个元类作为类的 *metaclass* 选项，这个元类用于创建类，而不使用内置 *type* 对象。
这允许你的代码读取、修改、甚至完全替换这个类，来进一步自定义其功能。
元类从技术上讲，可以是任意一个有效的Python调用（Python callable），但大多数元类都是继承于 *type*。
元类接收一个新类作为它的第一个参数，并且提供对这个类对象定义明细的访问。

下面的例子有助于你理解元类参数是怎么参与类定义的。（译者注：下面代码只是Python3可用）

>>> class MetaClass(type):
...     def __init__(cls, name, bases, attrs):
...         print('Defining %s' % cls)
...         print('Name: %s' % name)
...         print('Bases: %s' % (bases,))
...         print('Attributes:')
...         for (name, value) in attrs.items():
...             print('    %s: %r' % (name, value))
...
>>> class RealClass(object, metaclass=MetaClass):
...     spam = 'eggs'
...
Defining <class '__main__.RealClass'>
Name: RealClass
Bases: (<class 'object'>,)
Attributes:
    spam: 'eggs'
    __module__: '__main__'
__qualname__: 'RealClass'
>>> RealClass
<class '__main__.RealClass'>

注意这个类并没有实例化。
这个简单的例子演示了，怎么在类的创建过程中触发元类的执行。
注意 *__module__* 在属性列表中，一般来说Python类都会有这个属性。

这个例子使用了 *__ini__* 方法在类创建时执行一些特殊操作，我们也可以使用另外一个更强大的方法 *__new__* 来实现。
本章后面，Django会使用 *__new__* 来配置它的类。

.. seealso::

    兼容性：在Python2中使用元类

    Python3可以在类定义的时候直接传递参数，就像这里展示的 *metaclass* 参数一样。
    在Python2中，元类会被赋值到一个类变量　*__metaclass__* 里。
    事实上他们的效果一致，唯一的不同只是语法上的改变。

在一个基类上使用元类
------------------

元类非常有用，但 *metaclass* 参数是一个实现细节，不应该在定义类的过程中出现。
另一个问题是，在使用元类的过程中，这些新类并没有继承自一个特定的父类。
这意味着一些额外的方法和属性，必须在元类创建新类的时候提供。（译者注：我也没看懂这两句话，究竟是什么问题吖）

我们只需要一点技巧，就可以在一个Python类上，使用元类来解决以上问题。
当一个子类从父类身上继承属性的时候，父类的 *metaclass* 参数会自动继承下去。
这是一个简单有效的技巧，为所有的子类提供元类处理，而不需要每个子类单独定义 *metaclass* 参数。
接着上一章的例子，来看看继承 *RealClass* 会发生什么事情。

>>> class SubClass(RealClass): # 注意这里没有metaclass
...     pass
...
Defining <class '__main__.SubClass'>
Name: SubClass
Bases: (<class '__main__.RealClass'>,)
Attributes:
    __module__: '__main__'
__qualname__: 'SubClass'

可以看到，元类在幕后正常工作，子类完全不用操心。
只需要定义一个基类，子类就能继承到他所有的特性。
下一章将会讲述，Django利用这个技巧，实现一个使用非常广泛的特性。

陈述式语法（Declarative Syntax）
------------------------------

（译者注：并没有找到"Declarative Syntax"的权威翻译，
但Declarative Sentence（陈述句）是大家熟知的，
Declarative Programming也是大家熟知的，就是类似SQL这种语法非常接近于人类叙述的编程语言。
所以我觉得把declarative翻译为：陈述；陈述式的，会比字典里的翻译：宣告；声明，要更加贴切，
在此这斗胆翻译为“陈述式语法”）

Django的大部分工具都使用了一种叫“陈述式语法”的特性，令其读写和理解变得简单。
这种语法的目的是，最大限度减少“八股文式”的重复代码，使得代码更加优雅可读。
下面以一个Django模型为例。

.. code-block:: python

    class Contact(models.Model):
        """
        在网站上给作者留言，需要留下联系方式
        """
        name = models.CharField(max_length=255)
        email = models.EmailField()

这种陈述式语法，已经成为了Django代码的标志性特性，很多第三方应用也在学习Django提供类似的语法。
这种语法有助于开发者编写出易懂，紧凑的代码。
一旦你懂得怎样使用陈述式语法来创建类，你就可以很方便地调用Django的诸多特性，包括第三方社区提供的特性。

仔细观察陈述式语法，你就会发现，使用这种模式来为Django创建一个全新的框架是多么的容易。（译者注：这句话没翻译通）
在你的代码里使用陈述式语法，你和你的同事之间更加容易适配代码，提高生产效率。
归根到底，提高开发者效率，是Django和Python本身的第一要务。

以下几个小节只是讲述陈述式语法在Django中的运用，关于Django的ORM（object-relational mapper）会在本书第三章详细讲述。

集中式控制（Centralized Access）
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

一般而言，包会提供一个单独的模块，应用通过这个模块来访问包的工具集。
这个模块把其他地方的类和函数，引入到其命名空间下。
这样，这些类和函数还能使用原来的命名空间，而且现在他们被集中到了同一个地方。
（译者注：就如下面的例子那样，有关数据库的类和函数被集中到了 *django.db.models* 这个命名空间下）

.. code-block:: python

    from django.db import models

引入后，这个模块会至少提供一个基类，用于给子类继承。
其他的类被作为这些子类的属性类。
综合在一起，这些对象构成了我们需要的子类。

基类（Base Class）
^^^^^^^^^^^^^^^^

每个特性至少基于一个基类。
有可能因为框架的需要，会基于多个基类。
至少基于一个基类，只是为了使用这种语法。
如果没有基类，你只能叫你的使用者给每个类显式加上一个元类。
但这是一个实现的细节，使用者不应该需要知晓。

.. code-block:: python

    class Contact(models.Model): # models.Model就是一个基类

为了可以动态检查这些定义的属性，基类提供了一系列方法和属性让子类自动继承。
就像其他类一样，它可以根据框架的需要，提供简单或者复杂的功能。


属性类（Attribute Class）
^^^^^^^^^^^^^^^^^^^^^^^

属性类提供了一系列的类供给基类使用，这些属性类通常可以通过参数来自定义其行为。

.. code-block:: python

    class Contact(models.Model):
        # 下面两行就是属性类的使用
        name = models.CharField(max_length=255)
        email = models.EmailField()

这些属性类为框架带来了丰富多彩的特性，有一些甚至与我们常见的属性有很大区别。
它们会结合元类，提供一些额外的、幕后工作的功能，而不仅仅是属性赋值这么简单。
元类往往会读取这些属性类的参数来创建这些额外功能。

例如，Django的 *Model* 使用字段名称和字段属性来描述一个数据库实体表，这个数据库实体表还能根据类定义自动创建。
你可以通过字段名来访问数据表每列的数据，属性类还会根据自己的参数设定，把原生Python数据类型转换成相对应的数据库值。
更多关于Django怎么处理模型类和字段的详细内容，请看下一章分晓。

属性类排序
"""""""""

人们在使用陈述式语法的时候，有可能会感到困惑，因为Python字典是无序的，他并不能记录值被赋值的顺序。
在检视一个命名空间字典时，其实我们无法确认这些键的定义顺序（译者注：命名空间本质上就是一个字典，键就是里面定义的变量名称），当然我们还是有办法解决的。
如果框架需要遍历它的这些特殊属性，或者把这些属性展示给终端用户、程序员，那么，能以定义顺序来访问这些属性是有益处的。
这给了程序员一个控制属性顺序的机会，而不是任由程序语言来控制属性的顺序。

一个简单的解决方案是，让属性类自己来记录它们实例化的顺序，元类以此来排序。
当属性类都继承自一个特定的基类时，我们可以使用这个方法来记录属性类被实例化了多少次，并把次数赋值给属性类。

.. code-block:: python

    class BaseAttribute(object):
        creation_counter = 1
        def __init__(self):
            self.creation_counter = BaseAttribute.creation_counter
            BaseAttribute.creation_counter += 1

实例化的对象跟类不在同一个命名空间里，所以所有这个类的实例化对象都会有一个creation_counter属性，实例化时作为排序的依据。
解决属性类排序的方案有很多，但Django就是使用这个方法，来给模型和表单两者的字段排序。

类的定义
^^^^^^^


模块里面有了这些类， 我们创建一个应用类就简单多了，只需要定义一些子类和属性类。
不同框架的属性类名字有可能不一样，使用的时候，也会根据情况使用相应的类或者组合。
属性类还可能有一些保留名称，你在定义属性名称的时候不要使用这些保留名称，否则就会引起冲突，但是这种问题还是比较罕见的。
在你开发一个新框架时，如果用上这种陈述式语法，不建议设计使用保留名称。
一个通用原则是，开发者应该拥有最大的灵活性，而框架不应该干预。

.. code-block:: python

    from django.db import models

    class Contact(models.Model):
        """
        在网站上给作者留言，需要留下联系方式
        """
        name = models.CharField(max_length=255)
        email = models.EmailField()

上面这小段代码，框架已经把一大堆附加功能塞进新类 *Contact* 里，而不需要程序员手工来处理这个过程。
还需要注意的是，所有的这些属性类都是由同一个基础模块提供，并且实例化后赋值给模型。

一个类的定义有着无限潜力，不会仅限于框架提供的这些功能。
只要你写的是合法Python代码，你的类就可以包含大量的方法和其他属性，顺便混杂上框架提供的功能。

常见的鸭子类型（Duck Typing）协定
==============================

你可能已经听过这个古老的格言，“如果它走起路来像一只鸭子，叫起来像一只鸭子，那他就是一只鸭子”。
莎士比亚在写罗密欧与朱丽叶的时候，把这演绎得更加浪漫，“名称有什么关系？玫瑰不叫玫瑰，依然芳香如故。”。
上面反复强调的是，一个对象的名称并不影响它原本的功能。
其中心思想是，不管它身上已经贴了多少个标签，你都可以根据它的行为表现，合理认为它是什么东西。

在Python里，或者其他的一些语言，把这个概念扩展到了对象类型。
这时候，不再需要依赖某些基类或者接口，来定义一个对象可以做什么。
只要它实现了所需要的属性和方法，能够达到期望的目的就可以了。
在Python里一个广为人知的例子就是：*类文件对象（file-like object）* 。
任何对象只要实现了几个必要的方法，它就可以被视作Python文件对象。
利用这一点，很多库会返回他们自己的对象，其他函数可以把这些对象当作文件对象处理。
但同时这些对象又保留了一些特殊的属性，例如是否只读、被压缩、被加密、从某个互联网的源下载下来的，等等。

就像其他语言那样，同一个对象可以同时有多个接口，Python对象也可以同时有不止一种鸭子类型。
这并不是很常见，举个例子，在某些场景下，一个对象可能需要表现为一个字典，在其他场景下，需要表现为一个列表。
Django的 *HttpResponse* 对象就继承了这些行为（译者注：有时候是字典，有时候是列表），与此同时，还模仿了一个已打开（open）的文件对象。

在Django里，很多工具集都利用了鸭子类型，而不是定义一个特殊的基类。
这些工具集的特性定义了鸭子类型协议，为了使用到这些协议，对象必须提供相应的方法和属性。（译者注：什么分类协议？翻译不清楚了，这句话是我猜的）
大部分协议都可以在Django官方文档里面找到，本书会讲述更多的有关协议。
你会看到Django的一些超能力，其实也是利用了这个技术点。

下面的章节会描述一小部分大家用得比较多的Python协议，Django的构架大量使用了这些协议，你也可以在很多大型的Python库里看到这些协议的身影。

调用（Callable）
--------------

Python不但允许代码从源代码执行，任何行为与函数一致，可被调用的东西，都可以被执行。
所有的函数、类、方法，都是默认可被调用的。
实例化后的对象，可以通过提供一个方法，令自己像函数那样可被调用。

__call__(self[，...])
^^^^^^^^^^^^^^^^^^^^^

当一个实例化的对象，像函数那样被调用时，会执行这个方法。
这个方法跟其他普通的成员函数没什么两样，唯一的不同是，当对象被调用时它会被执行。

>>> class Multiplier(object):
...     def __init__(self, factor):
...         self.factor = factor
...     def __call__(self, value):
...         return value * self.factor
...
>>> times2 = Multiplier(2)
>>> times2(5)
10
>>> times2(10)
20
>>> times3 = Multiplier(3)
>>> times3(10)
30

Python提供了一个内置函数，来帮助判断一个对象是否可调用。
*callable()* 函数仅接受一个参数，返回 *True* 或者 *False* ，来判断一个对象是否能够像一个函数那样被调用。

>>> class Basic(object):
...     pass
...
>>> class Callable(object):
...     def __call__(self):
...         return "Executed!"
...
>>> b = Basic()
>>> callable(b)
False
>>> c = Callable()
>>> callable(c)
True

字典（Dictionary）
----------------

字典使用一个对象，来储存键和值的影射（mapping）（译者注：也就是我们常说的键值对）。
大部分的编程语言都有类似字典这种形式的数据结构，其他语言会叫他“hashes”、“maps”、“associative arrays”（译者注：分别是redis的哈希表，java的容器，php的其中一种数组形式）。
通常只需要通过指定的键，就可以访问相应的值。
Python的字典提供了很多方法，在颗粒度更细的层次下，进行底层影射的操控。
对象需要提供一些方法，使得它能像一个字典那样被使用，参考Python库文档可以得到更详细的描述。

__contains__(self,key)
^^^^^^^^^^^^^^^^^^^^^^

当使用 *in* 操作符时，此函数会被调用。
如果这个键（key）存在于底层影射中，则返回 *True*，否则返回 *False*。
这个函数永远不应该返回一个异常。

__getitem__(self,key)
^^^^^^^^^^^^^^^^^^^^^

如果这个键（key）存在于底层影射中，则返回跟这个键影射的值，否则应该抛出 *KeyError* 异常。

__setitem__(self,key,value)
^^^^^^^^^^^^^^^^^^^^^^^^^^^

这会根据指定键（key）来储存这个值（value），如果底层已经有这个键的影射，则把新的值覆盖旧值。

>>> class CaseInsensitiveDict(dict):
...     def __init__(self, **kwargs):
...         for key, value in kwargs.items():
...             self[key.lower()] = value
...     def __contains__(self, key):
...         return super(CaseInsensitiveDict, self).__contains__(key.lower())
...     def __getitem__(self, key):
...         return super(CaseInsensitiveDict, self).__getitem__(key.lower())
...     def __setitem__(self, key, value):
...         super(CaseInsensitiveDict, self).__setitem__(key.lower(), value)
...
>>> d = CaseInsensitiveDict(SpAm='eggs')
>>> 'spam' in d
True
>>> d['SPAM']
'eggs'
>>> d['sPaM'] = 'burger'
>>> d['SpaM']
'burger'

字典是需要能够 *可迭代（iterable）* 的，使用键的列表就可以循环字典的内容。
阅读下面 “可迭代” 小节来获取更多内容。

文件
----

正如之前所说，文件被广泛应用于获取信息的场景中。
Python库提供来类文件对象（file-like object），应用于与文件相关的函数中。
类文件对象不需要实现下面所有的方法，而是根据实际需要，实现相应的方法。
有了这种文件协议，对象可以很方便地实现读、写、读写兼备。
下面没有列出所有的方法，只列出了一些使用率比较高的。
你可以在Python标准库文档里，找到一份完整的文件协议方法清单，确保你会去查看文档获取更多细节。

read(self,[size])
^^^^^^^^^^^^^^^^^

从对象或者是它的信息源处获取数据。
可选参数 *size* 表示需要获取多少字节数据。
假如没有这个参数，函数应该返回尽可能多的数据（经常是整个文件，也可能是某个网络接口所有可用的字节)。

write(self,str)
^^^^^^^^^^^^^^^

把指定的 *str* 写进对象或者是它的信息源。

close(self)
^^^^^^^^^^^

关闭那些不再需要访问的文件。
可以用来释放出已经分配的内存资源，把文件内容提交到硬盘，或者只是为了满足协议的调用。
如果这个方法没有提供什么特殊的功能，它应该避免任何不必要的错误。

.. seealso::

    一个非常宽松的协议

    类文件对象有很多变种，因为这个协议是Python定义的，最为宽松的协议之一。
    有一小部分功能，比如：缓冲区输出、允许随机访问数据，等等，在一些场景里其实并不适用。
    所以在这些场景下设计的对象，会选择性地不实现某些方法。
    例如将会在第七章讲述到的，Django的HttpResponse对象，只允许按顺序写，所以它并不实现 *read()* 、 *seek()* 、 *tell()* ，假如在一些操作文件的库里使用它，可能会发生错误。

    常见的做法是，把这些不会用到的方法留空不实现，当访问到这些方法时，自然会抛出 *AttributeError* 异常。
    在一些场景下，程序员有可能需要去实现这些方法，但也只是简单抛出 *NotImplementedError* 异常，显示一个描述性更加强的信息。
    你必须在文档里面清楚写明，你的对象实现了什么协议。
    以防用户把这些对象当作标准文件使用，对于冒出的错误一头雾水，特别是在使用第三方库的时候。

可迭代的（Iterable）
------------------

假如一个对象作为参数传进内置函数 *iter()* 里，并且返回了一个迭代器（iterator），那么这个对象就可以被视为 *可迭代的（iterable）*。
*iter()* 在for循环里面经常会被隐式调用。
所有的列表、元组、字典都是可迭代的。
还有当新式类（new-style class）实现了以下方法后，也可以变成可迭代的。

__iter__(self)
^^^^^^^^^^^^^^

这个方法会在 *iter()* 里被隐式调用，并且返回一个迭代器，使得Python可以利用这个迭代器，从对象里获取元素。
我们常常会把 *__iter__()* 变成生成器函数，然后用这个生成器函数来生成一个迭代器，详细的内容会在下面“生成器”章节讲述。

>>> class Fibonacci(object):
...     def __init__(self, count):
...         self.count = count
...     def __iter__(self):
...         # 译者注：当iter()调用这个函数的时候，因为这个函数里面使用了yield，所以它会返回一个生成器对象，这个生成器对象同时也是一个迭代器
...         a, b = 0, 1
...         for x in range(self.count):
...             if x < 2:
...                 yield x
...             else:
...                 c = a+ b
...                 yield c
...                 a, b = b, c
...
>>> for x in Fibonacci(5):
...     print(x)
...
0
1
1
2
3
>>> for x in Fibonacci(10):
...     print(x)
...
0
1
1
2
3
5
8
13
21
34

迭代器
^^^^^

当使用内置函数 *iter()* 处理一个对象时，我们希望它返回一个迭代器，进而使用这个迭代器从对象中以序列的形式获取元素。
迭代器被用来单向遍历可用元素，每次只返回一个值，一直到没有为止。
对于一个非常大的集合而言，每次只取一个元素，要比一次性把元素加载到一个列表里更有效率。

next(self)
""""""""""

这是迭代器中唯一用到的方法，它会返回一个元素。
（译者注：注意“迭代器”和“迭代器协议”（iterator protocol）的区别，只要实现了 *next()* 方法即为迭代器，但迭代器协议需要把 *__iter()__* 方法也实现，并且约定返回自身）
如何返回元素，取决于这个迭代器是设计用来干嘛的，当它必须返回一个且只有一个元素。
当这个元素被所谓的迭代器处理后， *next()* 再次被调用，继续返回下一个元素。

一旦所有可用元素都被耗尽， *next()* 通过抛出 *StopIteration* 异常，来告诉Python停止使用迭代器，并在循环后继续运行。
Python会不断调用 *next()* 直到一个异常被抛出，形成了一个无限循环。
要么使用 *StopIteration* 优雅停止循环，要么使用另外一个异常，这引出一个更加麻烦的问题。

（译者注：下面的例子跟上面的例子实现的功能其实是一样的，不同的是，上面的例子利用yield关键字，让Python帮忙生成了一个迭代器，而下面的例子则是手工完成了这个迭代器。）

.. code-block:: python

    class FibonacciIterator(object):
        def __init__(self, count):
            self.a = 0
            self.b = 1
            self.count = count
            self.current = 0
        def __next__(self):
            self.current += 1
            if self.current > self.count:
                raise StopIteration
            if self.current < 3:
                return self.current - 1
            c = self.a + self.b
            self.a = self.b
            self.b = c
            return c
        next = __next__
        def __iter__(self):
            # 它自己本身就是迭代器，所以返回自身
            return self

    class Fibonacci(object):
        def __init__(self, count):
            self.count = count
        def __iter__(self):
            return FibonacciIterator(self.count)

注意上面的迭代器（FibonacciIterator）不需要显式定义 *__iter__()* 也能正常使用。
包含这个方法只是为了说明，在循环里也可以直接使用迭代器（译者注：而不需要Fibonacci在外层再包装了下）。

.. seealso::

    兼容性：在Python2中使用迭代器

    Python3对于迭代器只有一个非常小的改变。
    在这里的 *__next__()* 方法在Python3之前叫做 *next()* 。
    注意Python3添加的这个下划线。
    Python3的这个改变，是为了遵从Python魔术方法的命名习惯，魔术方法就是在方法名字的前后添加双下划线。

    如果你需要同时支持Python2和3，解决方法也很简单。
    就像Fibonacci例子那样，在定义 *__next__()* 之后，你可以把 *__next__()* 方法直接赋值给 *next* ： *next = __next__* 。
    这句话可以放到类定义里面的任何位置，但他最好紧接着 *__next__* 方法后面，这可以令代码保持紧凑。

生成器(Generator)
^^^^^^^^^^^^^^^^

（译者注：可迭代的、迭代器、生成器函数（generator function）、生成器对象（generator object），这四个概念比较容易混淆，我在这里总结下。
一个对象是否可迭代，看它的 *__iter__* 函数是否返回迭代器。
一个对象是否迭代器，看它有没有 *next* 函数。
迭代器不一定是可迭代的，它们之间没有必然的关系，只是名字都带有“迭代”二字而已。
一个函数是否为生成器函数，看它函数体内有没有 *yield* 语句。
当生成器被当作函数调用，它返回的是一个生成器对象实例。
这个生成器对象实例，其实是迭代器（因为它有 *next* 函数），它同时也是可迭代的（它的 *__iter__* 函数返回自己，也就是一个迭代器）。
生成器（Generator）其实不是一个严谨的语法元素，只是口语上的范指，以防混淆，下面的翻译只会使用：生成器函数、生成器对象。
）

正如上面斐波纳契（Fibonacci）数列的例子（译者注：第一个Fibonacci的例子），我们可以利用生成器函数来生成简单迭代器，而不需要定义一个单独的迭代器类（译者注：就像第二个Fibonacci例子那样单独定义了一个FibonacciIterator迭代器类）。
Python判断一个函数是否生成器函数的标准是：这个函数里面有没有 *yield* 语句，这会使得这个函数的行为与其他函数有所不同。

当调用一个生成器函数时，Python不会立马执行它的代码。
这时，它会返回一个迭代器（生成器对象），这个迭代器的 *next()* 方法会调用函数体代码，一直运行到第一个 *yield* 语句的位置。
yield语句的返回值，会当作 *next()* 方法的结果返回，这时候生成器对象就得到了这个运算结果。

当下一次迭代器再调用 *next()* 函数时，Python继续在生成器函数上一次离开的地方开始执行，它的所有变量都保持原来离开的状态不变。
Python遇到 *yield* 语句会不断重复这个过程，就像使用一个循环来yield这个值。
当这个函数结束的时候，不再yield出一个值来，这个迭代器会自动抛出 *StopIteration* 异常来告诉循环是时候结束了，接下来的代码会继续运行。

序列（Squence）
-------------

迭代器描述了这么一个对象：你每次可以从这个对象获取一个值，而且我们知道这个对象储存了所有这些值。
这种对象就叫 *序列*。
列表和元组，是两种最广为人知的序列类型。
作为可迭代的元素，序列也使用 *__iter__()* 方法来逐个返回他们的值。但由于这些值是可被预见的，我们可以使用上一些附加的功能。

__len__(self)
^^^^^^^^^^^^^

当所有值都是可用时，序列会有一个确定的长度，你可以用内置函数 *len()* 来获取这个长度。
它的内部实现是：*len()* 会检查对象是否有 *__len__()* 方法，有的话则使用它来获取序列的长度。
因此，*__len__()* 应该返回一个整数，也就是这个序列包含元素的个数。

理论上，*__len__()* 不需要知道里面有什么元素，只需要知道里面有多少个元素。
因为不可能有半个元素出现，一个元素要么存在要么不存在，*__len__()* 应该返回一个整数。
即使返回的不是整数，*len()* 也会强制返回一个整数。

>>> class FibonacciLength(Fibonacci):
...     def __len__(self):
...         return self.count
...
>>> len(FibonacciLength(10))
10
>>> len(FibonacciLength(2048))
2048

__getitem__(self)和 __setitem(self,value)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

在一个序列里面，所有的值都已经是排序好的，所以是可以通过它们在序列里的索引，来访问某个相应的值。
访问的语法与字典完全一致，所以Python复用之前字典的两个方法。
这能让序列自定义它每个值会被怎么访问，或者限制序列设置新的值，做到只读的效果。

百变函数（Augmenting Function）
============================

除了标准声明和调用外，Python还提供了多种方式，让你使用有趣的方法来调用函数。
Django使用这些技术点来高效重用代码。
你也可以在你的应用里使用相同的技术，皆因它们是标准Python的一部分。

额外的参数（Excess Argument）
--------------------------

在运行的时候，不总是能预先知道，有什么参数提供了给函数。
Django就经常出现这种情况，在子类自己被配置恰当之前，类方法已经在源代码里被定义了。（译者注：这句话说的究竟是什么场景下会出现？）
另外一个常见的场景是，一个函数可以接受很多种不同对象作为参数。
此外还有些场景是，为了其他应用可以使用这一系列的API， 函数调用回自己本身。（译者注：链式函数？）

为了应对以上场景，Python还提供了两种“动态”的方式来定义函数参数，允许函数接受额外参数，而不受显式定义参数的限制。
下面将介绍这些"额外"的参数。

注意 *args* 和 *kwargs* 的名字仅仅是Python的命名惯例，你也可以用其他的名字。
作为函数参数，你可能会根据自己的喜好来命名他们。
但如果跟标准Python惯例保持一致，你的代码对于其他程序员来说，可读性就更高了。

位置参数（Positional Arguments）
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

在参数前加一个星号，函数就可以接受任意多个位置参数。

>>> def multiply(*args):
...     total = 1
...     for arg in args:
...     total *= arg
...     return total
...
>>> multiply(2, 3)
6
>>> multiply(2, 3, 4, 5, 6)
720

Python把这些位置参数放进一个元组里，你可以通过变量 *args* 进行访问。
如果定义了位置参数，但你实际使用又没有提供任何参数，一个空元组就会赋值到 *args* 。

关键词参数（Keyword Argments）
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Python在参数前加两个星号，使函数支持任意多个关键词参数。

>>> def accept(**kwargs):
...     for keyword, value in kwargs.items():
...     print("%s -> %r" % (keyword, value))
...
>>> accept(foo='bar', spam='eggs')
foo -> 'bar'
spam -> 'eggs'

值得注意的是，*kwargs* 只是一个普通的Python字典，里面包含了参数的名字和值。
如果没有额外的关键词参数提供， *kwargs* 是一个空字典。

混合参数类型（Mixing Argument Types）
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

你定义的标准参数，可能会跟位置参数和关键词参数一起使用。
把他们混在一起时要格外小心，因为他们的顺序会影响Python对其解析。
我们把参数分成四类，不是所有的分类都是必须的，但他们定义时必须依照以下顺序，不能跳过任何项。

- 必选参数（Required arguments）
- 可选参数（Optional arguments）
- 额外位置参数（Excess positional arguments）
- 额外关键词参数（Excess keyword arguments）

.. code-block:: python

    def complex_function(a, b=None, *c, **d):

之所以需要依照这个顺序，是因为函数传递进来的值，没有放置到其他参数下时， **args* 和 ***kwargs* 才能接收到值。
假如没有这个顺序，当你调用一个有位置参数的函数时，Python无法判断传进的值，是应该赋给定义好的参数还是额外位置参数。

还有需要注意的是，函数可以接受任意多个的必选参数和选填参数，但额外参数分别只能有一个。

传递参数的集合（Argument Collections）
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

为了使函数可以接收到参数的集合，Python代码在调用函数时，使用之前的星号语法，则传递可以任意个数的参数。
使用这种方法来传递参数时，Python会把参数展开成一个普通的列表，

我们可以使用这种方法来进行Python调用，它可以和标准参数组合一起用，但仍然要遵从上面所说的优先级规则。

>>> def add(a, b, c):
...     return a + b + c
...
>>> add(1, 2, 3)
6
>>> add(a=4, b=5, c=6)
15
>>> args = (2, 3)
>>> add(1, *args)
6
>>> kwargs = {'b': 8, 'c': 9}
>>> add(a=7, **kwargs)
24
>>> add(a=7, *args)
Traceback (most recent call last):
...
TypeError: add() got multiple values for keyword argument 'a'
>>> add(1, 2, a=7)
Traceback (most recent call last):
...
TypeError: add() got multiple values for keyword argument 'a'

正如这个例子最后一行的描述，在显式传递关键词参数时，还需要传递一个元组作为额外位置参数，这时你要特别小心。
因为当Python展开这些额外的参数后，根据优先级规则，位置参数会优先解析。
在这个例子里，最后两个调用是完全一样的，Python分不清楚哪个值是赋值给 *a* 的。
（译者注：他说完全一样我就困惑了，虽然错误是一样的，但输入的参数不一样阿，这里可以深入挖掘了下）

装饰器
------

改变函数行为的常见方法还有 -- 把他用另外一个函数进行“装饰”。
装饰器也常常被称为“包装”（wrapping）函数，在调用原函数之前或者之后，执行一些额外代码。

装饰器的本质是，接收一些可执行玩意，然后再返回一些新的可执行玩意。
被装饰器返回的函数，稍后会被执行。（译者注：为什么是在装饰器执行后稍后执行？）
必须注意的是：保证原来的函数在这个过程中没有被遗弃，否则在不重新加载模块的情况下，你无法找回它。

装饰器可以在很多场景下使用，可以装饰一个你直接定义的函数，也可以装饰一个在其他地方定义的函数。
自Python2.4后，装饰器使用一种新语法来装饰函数。
在过去的Python版本里，使用的是一种稍微不同的语法，但其实装饰器的代码是一样的；唯一不同的是，装饰器应用在函数上时，使用的语法不一样。

.. code-block:: pycon

    >>> def decorate(func):
    ...     print('Decorating %s...' % func.__name__)
    ...     def wrapped(*args, **kwargs):
    ...         print("Called wrapped function with args:", args)
    ...         return func(*args, **kwargs)
    ...     print('done!')
    ...     return wrapped
    ...
    >>> # Python 2.4或以上
    >>> @decorate
    ... def test(a, b):
    ...     return a + b
    ...
    Decorating test...
    done!
    >>> test(13, 72)
    Called wrapped function with args: (13, 72)
    85
    >>> # Python 2.3 语法
    >>> def test(a, b):
    ...     return a + b
    ...
    >>> test = decorate(test)
    Decorating test...
    done!
    >>> test(13, 72)
    Called wrapped function with args: (13, 72)
    85

这种旧的语法，是另外一种装饰函数的方式，当 *@* 语法不可用时，这种方式就可以派上用场了。
考虑到一个函数会在其他地方定义，但还是应该能够被装饰到。（译者注：这里想表达啥）
一个函数，被传递到装饰器里，返回一个新函数，新函数里把一切所需的都装饰好。
使用这种方式，任何可被调用的玩意，无论它来自哪，用来干啥，都可以被装饰器包装。

使用额外参数进行包装
-----------------

有时装饰器对于接收到的这个函数，需要一些额外信息来判断，应该对这个函数做些什么。
使用老的装饰器语法，或者装饰任意函数的时候（译者注：为什么装饰任意函数？），很容易就可以做到这个效果。
只需定义装饰器时，接受额外参数获取相应的信息，在函数被包装时，再提供这些信息。

>>> def test(a, b):
...     return a + b
...
>>> def decorate(func, prefix='Decorated'):
...     def wrapped(*args, **kwargs):
...         return '%s: %s' % (prefix, func(*args, **kwargs))
...     return wrapped
...
>>> simple = decorate(test)
>>> customized = decorate(test, prefix='Custom')
>>> simple(30, 5)
'Decorated: 35'
>>> customized(27, 15)
'Custom: 42'

然而，Python2.4的装饰器语法，令到这件原本简单的事情变复杂了。
当使用新语法的时候，装饰器永远只能接收仅此一个参数：需要包装的函数。
所以有其他的方式，使到装饰器能够获取额外的参数，但我们先讨论一下什么是“偏爱”（partials）

偏应用函数（Partial Application of Functions）
-------------------------------------------

典型地，当函数在被执行的时候，会带上所有必须的参数被调用。
有时候，参数已经预先知道，远在函数被调用之前。
在这些情况下，函数可以先应用一个或者几个他的参数，使得在后面可以应用更少的参数。


为了这个目的，Python2.5在他的functools模块包含了partial对象。
他接受一个可执行，还有任意个数的额外参数，再返回一个新的可执行，看上去就像原来的一样，唯一的不同是，在后面的使用中，不需要指定这些已经预加载的参数。

>>>

Python2.5后面的版本，Django提供了他自己对partial的实现，叫加里函数，位于django.utils.functional。
这个函数可以在Python2.3或者更高版本运行。


回到装饰器问题
------------
正如之前描述的那样，装饰器使用Python2.4的语法，会导致一个问题，如果他们要接收额外的参数，当语法只是提供了唯一一个参数，就是被包装的函数本身。
使用偏应用技术，就可以在装饰器上预加载参数。
更早描述这个装饰器，下面的例子使用了curry(在第九章描述的)，在使用更新的Python2.4语法时，提供参数给装饰器。

>>>

这仍然不是很方便，因为函数每次都需要通过curry来装饰另外一个函数。
一个更好的方法是，在装饰器内部来直接提供这个功能。
这就需要装饰器里写一些额外的代码，但可以令到他更容易使用。

这个技巧就是在另一个函数里面定义这个装饰器，这个函数能够接受参数。
这个新的外层函数会返回装饰器，这个装饰器稍后会被当作标准的Python装饰器使用。
这个装饰器这次反过来会返回一个函数，在装饰过程完成后，会被下面的程序使用到。

这真的非常抽象，我们来看看下面的代码，跟之前的例子功能一样，但是没有依赖curry，使到他更加容易使用。

>>>

单参数被期望时，这种场景下，这种技术使用得最为合理。
如果装饰器应用时，没有带任何的参数，为了使到它工作正常，括号依然是需要的。

>>>

第二个例子失败了是因为我们一开始没有调用 decorate。
因此，所有调用test的子请求，发送他们的参数给decorator而不是test。
这是一个错误匹配，Python抛出一个错误。
这种场景比较难调试，因为精确的异常抛出，这个异常依赖于被包装的函数。


一个装饰器，有或者没有参数
======================






描述符
======

自省机制
=======


已应用技术点
==========

下一步
=====
































































